[{"content":"SpringBoot3 实现登录注册功能-1 仅仅是一枚新手实现功能的记录。仅是一个参考，还有很多不足，后续再完善。\n该文主要是学习了简单的登录注册功能、邮箱验证、拦截器的设置。\n后续还得学习上验证码的生成以及时效性、设置前端header、springBoot security(本来是有用到的，但是频繁出现小问题，决定先不用后续再学习。)还有邮箱验证登录等等。\n也会有一些不同的注册思路需要学习。\n流程、接口 简单提一嘴：dto\\do ： do也就是实体类，和数据库一一对应，dto是层与层之间交互的实体类，用来封装前端传来的数据。\n由于没有前端，简单了解一下流程：\n注册：\n用户输入用户、密码、邮件进行注册，会发送验证码进行注册，验证码验证成功后将数据存储到数据库中。\nimage-20241120211610319\r数据库表: userid 、username 、password、 email\n发送邮件： 要实现发送邮箱验证，使用 spring mail\n添加依赖：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-mail\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 用qq邮箱，配置邮箱客户端\nimage-20241120232744235\r开启服务后就会有个授权码，要配置到yml文件中。\n1 2 3 4 5 6 7 8 spring: #邮件服务配置 mail: host: smtp.qq.com #邮件服务器地址 protocol: smtp #协议 username: #发送邮件的邮箱也就是你开通服务的邮箱 password: #开通服务后得到的授权码 default-encoding: utf-8 #邮件内容的编码 接着就可以使用了，简单示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * 点击发送验证码给对应的邮箱 * @param email 邮箱 */ @Override public void sendEmail(String email) { //生成对应的验证码取uuid的0-6位 String code = UUID.randomUUID().toString().substring(0,6); // 设置邮箱要发送的信息： String subject = \u0026#34;健康管理系统的验证码\u0026#34;; String message = \u0026#34;验证码为：\u0026#34;+code; // 创建一个mailMessage对象 SimpleMailMessage mailMessage = new SimpleMailMessage(); // 设置发送的邮箱 mailMessage.setFrom(\u0026#34;1320104286@qq.com\u0026#34;); mailMessage.setTo(email); // 设置主题和内容 mailMessage.setSubject(subject); mailMessage.setText(message); // 发送邮件 mailSender.send(mailMessage); } 注册基础功能实现 流程：\nimage-20241121001127648\r邮箱验证 先完成邮件的验证（暂时是临时存储，以及随机的uuid进行注册）\nController层\n1 2 3 4 5 6 7 8 @PostMapping(\u0026#34;/verify\u0026#34;) public Result add(@RequestBody EmailDto emailDto) { log.info(\u0026#34;给邮箱{}发送验证码\u0026#34;,emailDto.getEmail()); userService.sendEmail(emailDto.getEmail()); return Result.success(\u0026#34;邮件已发送\u0026#34;); } } Service 层\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 临时存储邮箱和对应的验证码 private Map\u0026lt;String,String\u0026gt; verifyCodes = new HashMap\u0026lt;\u0026gt;(); @Override public void sendEmail(String email) { //生成对应的验证码取uuid的0-6位 String code = UUID.randomUUID().toString().substring(0,6); verifyCodes.put(email,code); // 到时候这部分修改一下 String subject = \u0026#34;健康管理系统的验证码\u0026#34;; String message = \u0026#34;验证码为：\u0026#34;+code; SimpleMailMessage mailMessage = new SimpleMailMessage(); mailMessage.setFrom(\u0026#34;1320104286@qq.com\u0026#34;); mailMessage.setTo(email); mailMessage.setSubject(subject); mailMessage.setText(message); mailSender.send(mailMessage); } 实现注册 实现注册：需要对密码进行处理，以及对数据库进行查询是否存在。\nController\n1 2 3 4 5 6 7 8 9 @PostMapping(\u0026#34;/register\u0026#34;) public Result add(@RequestBody RegisterDto registerDto) { Integer Id = userService.register(registerDto); if( Id== null) { return Result.error(\u0026#34;用户名或邮箱已经存在！注册失败！\u0026#34;); } return Result.success(\u0026#34;用户创建成功，id为:\u0026#34;+Id); } service\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * 对包含 验证码的请求进行处理。 * @param registerDto web端传进来的参数。 * @return 返回 用户的id,感觉有点多余 */ @Transactional(rollbackFor = Exception.class) @Override public Integer register(RegisterDto registerDto) { // 如果已经存在用户了，则无法注册 if(userMapper.getByUserNameOrEmail(registerDto.getUsername()) != null) { return null; }else{ // 没有找到用户 log.info(\u0026#34;用户不存在，可以注册！\u0026#34;); //这里去获取user里的临时存储的code String code = verifyCodes.get(registerDto.getEmail()); // 验证code是否正确且验证对应的email(上面获取code的过程就判断了) if(code != null \u0026amp;\u0026amp; code.equals(registerDto.getCode())) { // 这里要处理user的password ! String secretPass = PassUtils.encryptPassword(registerDto.getPassword()); registerDto.setPassword(secretPass); userMapper.add(registerDto); return userMapper.getIdByUserName(registerDto); } // 注册失败 return null; } } 这里的密码加密采用的Bcrypt 算法，会随机生成盐对密码进行加密，且不可逆，是最主流的密码加密算法。\n密码加密： 需要导入依赖：\n1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/org.mindrot/jbcrypt --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mindrot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jbcrypt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 编写PassUtils类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class PassUtils { /** * 加密密码 * @param plainPassword 明文密码 * @return 加密后的密码*/ public static String encryptPassword(String plainPassword) { return BCrypt.hashpw(plainPassword,BCrypt.gensalt()); } /** * 验证密码 * @param plainPassword 明文密码 * @param encryptedPassword 加密后的密码 * @return 验证结果*/ public static boolean verifyPassword(String plainPassword, String encryptedPassword) { return BCrypt.checkpw(plainPassword,encryptedPassword); } } 注册测试： 根据流程，需要接收前端的Email，封装到EmailDto类中，会发送验证码。\nimage-20241121003214150\r对应的邮箱接收到了验证码，也就证明注册成功。\nimage-20241121003530208\r查看数据库：证明注册成功。\nimage-20241121003621821\r这里说明一下：BCrypt 加密后长度固定为60个字符。\n登录 对应的登录流程也需要对密码进行校验，这里要学习的关键是jwt身份认证\nController （这里应该为前端访问的用户设置header token = jwt,先将jwt返回给前端，由前端setheaders ）\n1 2 3 4 5 6 7 8 9 10 11 12 @PostMapping(\u0026#34;/login\u0026#34;) public Result login(@RequestBody LoginDto loginDto) { log.info(\u0026#34;登录的账号：{}，{}\u0026#34;,loginDto.getUsername(),loginDto.getPassword()); String jwt = userService.login(loginDto); if(jwt != null) { return Result.success(jwt); } return Result.error(\u0026#34;登录失败\u0026#34;); } service (关键在于密码的验证)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * 登录接口 * @param loginDto 控制层传输过来的信息 * @return 返回jwt */ @Override public String login(LoginDto loginDto) { /* 验证账号和密码，并生成jwt进行返回 */ // 这里应该换成dto,后面再修改,还有VO // 密码加密再进行查询 UserDo userDo = userMapper.checkLogin(loginDto); log.info(\u0026#34;要登录的用户:{}\u0026#34;,userDo); if(PassUtils.verifyPassword(loginDto.getPassword(),userDo.getPassword())) { log.info(\u0026#34;登录成功设置返回jwt\u0026#34;); // 并设置为普通用户 return JwtUtils.generateJwt(loginDto.getUsername(),\u0026#34;user\u0026#34;); } log.info(\u0026#34;账号或密码错误!\u0026#34;); return null; } Mapper层很简单：就是根据用户用户名查询对应的数据userDo.\njwt 简单来说 jwt令牌 就是一种身份认证，你只有带有对应的令牌才能有对应的权限。（结合拦截器使用，进行登录验证）\n关于jwt的相关知识，可以看https://blog.csdn.net/shenyunmomie/article/details/139805325\n和https://blog.csdn.net/weixin_43443913/article/details/140479283 进行了解，这里就不赘述了。\n快速入门：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!--jwt相关依赖 jdk1.8 以前就只需要导第一个--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.12.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-impl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.12.6\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 编写jwtUtils\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @Data @Component @ConfigurationProperties(prefix = \u0026#34;jwt\u0026#34;) // 从配置文件中获取相关的属性值 public class JwtUtils { // 签名算法需要的密钥 private static long expiration = 12*60*60*1000; //有效期是12小时 private static SecretKey key = Jwts.SIG.HS256.key().build(); //密钥是随机生成的。 /** * 生成token * @param name 用户名 * @param subject 用户类型 * @return 返回token */ public static String generateJwt(String name, String subject) { String jwt = Jwts.builder() .subject(subject) // 设置主题一般是用户类型 .issuedAt(new Date()) .claim(\u0026#34;name\u0026#34;,name) .signWith(key) .expiration(new Date(System.currentTimeMillis()+expiration)) // 设置有效期 .compact(); return jwt; } /** * * @param jws jws字符串 * @return 返回一个对象 */ public static Object parseJwt(String jws) { return Jwts.parser() .verifyWith(key) .build() .parseSignedClaims(jws); } } 然后再登录后根据其用户名生成一个jwt.\n登录测试： image-20241121005845573\r拦截器 就是当没有带合法jwt的用户都会被拦截，只能访问登录注册页面。\n编写登录拦截器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Slf4j @Component public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest req, HttpServletResponse resp, Object handler) throws Exception { Gson gson = new Gson(); String jwt = req.getHeader(\u0026#34;token\u0026#34;); // 1 判断是否存在 jwt 不存在则返回错误结果 if(StringUtil.isNullOrEmpty(jwt)) { log.info(\u0026#34;token为空，返回未登录信息！\u0026#34;); Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); // 手动转成json对象 -- 阿里巴巴 的fastJson String notLogin = gson.toJson(error); resp.getWriter().write(notLogin); return false; } // 5 判断jwt是否被篡改或者失效 try{ JwtUtils.parseJwt(jwt); }catch (Exception e) { log.info(\u0026#34;jwt被篡改或失效，返回登录信息\u0026#34;); Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); // 手动转成json对象 -- 阿里巴巴 的fastJson String notLogin = gson.toJson(error); resp.getWriter().write(notLogin); return false; } // 6 放行 log.info(\u0026#34;令牌合法！放行！\u0026#34;); return true; } } 配置拦截器\n1 2 3 4 5 6 7 8 9 10 @Configuration public class LoginConfig implements WebMvcConfigurer { @Autowired private LoginInterceptor loginInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(loginInterceptor).addPathPatterns(\u0026#34;/**\u0026#34;).excludePathPatterns(\u0026#34;/login\u0026#34;,\u0026#34;/register\u0026#34;,\u0026#34;/verify\u0026#34;,\u0026#34;/swagger-ui/index.html\u0026#34;); } } 全局异常处理器 由于开发过程中多多少少会出现一些异常。因此可以设置一个全局异常管理器去管理没有被处理的异常，保证程序可以正常使用。\n很简单就不赘述了。\n1 2 3 4 5 6 7 8 9 10 11 12 @Slf4j @RestControllerAdvice public class GlobalException { // 处理所有异常 @ExceptionHandler(Exception.class) public Result ex(Exception e) { e.printStackTrace(); return Result.error(\u0026#34;对不起,操作失败,请联系管理员!\u0026#34;); } } 总结： 到此我们就完成了一个相对完整且基础的登录注册流程，使用了jwt\\拦截器、异常处理、BCrypt进行密码加密存储以及邮箱验证。\n","date":"2024-11-20T21:09:40+08:00","permalink":"http://localhost:1313/2024/springboot%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E5%92%8C%E7%99%BB%E5%BD%95/","title":"SpringBoot实现注册和登录"},{"content":" 这两天学习了GUI编程后，实现的小项目，还有记事本，记事本难点较少，画图板自己解决不了，遂记录一下\n画画板项目 要求：\n开发一款简单的画图软件, 包含如下功能：\n画笔 矩形/椭圆绘制 清屏 橡皮擦 直线/带箭头的直线 修改画笔颜色、背景颜色 代码框架都是有套路的，找一个自己用得顺得模板。\n基本框架 要先理清要完成的功能！\n组件的实现 组件的事件绑定 组件事件的完成 组件的实现比较容易：只有8个按钮和1个画板\n组件事件的完成：要理清每一种功能的本质\n组件的事件绑定：这里的难点在于按下按钮要执行对应的事件，也就是一个事件要和 “按钮”、“画布“进行绑定\n这里学到的事件和两个按钮绑定的方法：利用一个eventManager()方法：\n在按钮组件里，加上name属性 左键按钮事件，绑定eventManager()方法 eventManager中获取点击组件的name属性，根据name属性执行对应的功能方法 组件事件的完成也是相对困难的(之前并未了解到)\n需要先了解过程：\n点击\u0026mdash;绘画\u0026mdash;释放 ，一次绘画，包含着三个过程\n点击\u0026mdash;》进入eventManager方法\u0026mdash;\u0026gt;调用对应功能的方法（执行无数次）\u0026mdash;\u0026gt;释放，将参数清零\n注意点：\n在事件函数前都要加上一个 begin方法，将flag设置为1，stop方法（绑定左键释放）的时候，再修改成0。\n也应该为每次设置一个 lastDraw参数。要理解，绘画过程其实是无数次事件执行，比如矩形，就是起始点和鼠标点形成矩形，但是在绘画是，我们不希望每时刻的矩形都被出现，只需要最后一个矩形，因此需要设置参数，每次开始前beigin方法将其删除。（canvas返回的是id）没有释放的效果如下：\nimage-20240902093708969\r具体实现 相关参数： 1 2 3 4 5 6 7 8 9 10 11 12 def __init__(self,master=None,bgcolor=\u0026#34;#000000\u0026#34;): super().__init__() self.master = master self.bgcolor = bgcolor #背景色，也是橡皮檫的色 self.canvas = None # 画布 self.fgcolor = \u0026#34;#ff0000\u0026#34; # 线条的颜色 self.x = 0 #这个用于保存刚刚点击时的坐标 self.y = 0 self.lastDraw = 0 # 用以记录 canvas返回的id,以便管理绘画的周期 self.startDrawFlag = False # 绘画开关 self.pack() self.createWedigt() 组件的创建： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def createWedigt(self): # 1. 创建画布，背景为黑色 self.canvas = Canvas(root,background=self.bgcolor,width=800,height=400) self.canvas.pack() # 2. 创建按钮 btn01 = Button(self, text=\u0026#34;开始\u0026#34;,name=\u0026#34;start\u0026#34;) btn01.pack(side=\u0026#34;left\u0026#34;,padx=5) btn02 = Button(self, text=\u0026#34;画笔\u0026#34;, name=\u0026#34;pen\u0026#34;) btn02.pack(side=\u0026#34;left\u0026#34;,padx=5) btn03 = Button(self, text=\u0026#34;画矩形\u0026#34;,name=\u0026#34;rect\u0026#34;) btn03.pack(side=\u0026#34;left\u0026#34;,padx=5) btn04 = Button(self, text=\u0026#34;清屏\u0026#34;,name=\u0026#34;clear\u0026#34; ) btn04.pack(side=\u0026#34;left\u0026#34;,padx=5) btn05 = Button(self, text=\u0026#34;橡皮檫\u0026#34;, name=\u0026#34;erasor\u0026#34;) btn05.pack(side=\u0026#34;left\u0026#34;,padx=5) btn06 = Button(self, text=\u0026#34;直线\u0026#34;, name=\u0026#34;line\u0026#34;) btn06.pack(side=\u0026#34;left\u0026#34;,padx=5) btn07 = Button(self, text=\u0026#34;直线（箭头）\u0026#34;, name=\u0026#34;lineArrow\u0026#34;) btn07.pack(side=\u0026#34;left\u0026#34;,padx=5) btn08 = Button(self, text=\u0026#34;颜色\u0026#34;,name=\u0026#34;color\u0026#34;) btn08.pack(side=\u0026#34;left\u0026#34;,padx=5) # 3 进行事件绑定！！ 注意看 # bind_class 绑定所有Button按钮 btn02.bind_class(\u0026#34;Button\u0026#34;,\u0026#34;\u0026lt;Button-1\u0026gt;\u0026#34;,self.eventManager) # 绑定释放按钮 self.canvas.bind(\u0026#34;\u0026lt;ButtonRelease-1\u0026gt;\u0026#34;,self.stopDraw) eventManager的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def eventManager(self,event): name = event.widget.winfo_name() print(name) if name == \u0026#34;line\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;,self.line) elif name == \u0026#34;lineArrow\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.linewithhead) elif name == \u0026#34;rect\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.rect) elif name == \u0026#34;pen\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.pen) elif name == \u0026#34;erasor\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.Erasor) elif name == \u0026#34;clear\u0026#34;: # clear 就删除所有 self.canvas.delete(\u0026#34;all\u0026#34;) elif name == \u0026#34;color\u0026#34;: # 调起颜色选择器，设置到fgcolor属性 c = askcolor(color=\u0026#34;black\u0026#34;, title=\u0026#34;选择画笔颜色\u0026#34;) self.fgcolor = c[1] elif name == \u0026#34;start\u0026#34;: messagebox.showinfo(\u0026#34;你好！\u0026#34;,\u0026#34;开始画画\u0026#34;) 事件的实现： 开始结束：\n1 2 3 4 5 6 7 8 9 10 11 12 13 def stopDraw(self,event): print(\u0026#34;绘画结束\u0026#34;) self.startDrawFlag = False # 每次结束后重置，避免刚刚画的被下一个操作的begin()删除 self.lastDraw = 0 def begin(self,event): # 删除绘画过程中不必要的图像 self.canvas.delete(self.lastDraw) if not self.startDrawFlag: self.startDrawFlag = True self.x = event.x #保存当前位置的坐标 self.y = event.y 不同功能实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def pen(self,event): self.begin(event) self.canvas.create_line(self.x,self.y,event.x,event.y,fill=self.fgcolor) self.x = event.x self.y = event.y def rect(self,event): self.begin(event) self.lastDraw = self.canvas.create_rectangle(self.x,self.y,event.x,event.y,outline=self.fgcolor) def Erasor(self,event): \u0026#34;\u0026#34;\u0026#34;其实就是线条白色\u0026#34;\u0026#34;\u0026#34; self.begin(event) self.canvas.create_rectangle(event.x-4,event.y-4,event.x,event.y,fill=self.bgcolor) self.x = event.x self.y = event.y def line(self,event): self.begin(event) # 以记录的xy 到当前鼠标的xy self.lastDraw = self.canvas.create_line(self.x,self.y,event.x,event.y,fill=self.fgcolor) def linewithhead(self,event): self.begin(event) self.lastDraw = self.canvas.create_line(self.x,self.y,event.x,event.y,arrow=LAST,fill= self.fgcolor) 将python文件生成exe文件 本质：把python解释器和py文件捆绑，生成exe文件\n使用pyinstaller模板\n1 pyinstaller -F xxx.py 最终代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 \u0026#34;\u0026#34;\u0026#34; 开发一款简单的画图软件, 包含如下功能： 1. 画笔 2. 矩形/椭圆绘制 3. 清屏 4. 橡皮擦 5. 直线/带箭头的直线 6. 修改画笔颜色、背景颜色 \u0026#34;\u0026#34;\u0026#34; # 尽力完成，结构更加重要 # 单行文本框 from tkinter import * from tkinter import messagebox from tkinter.colorchooser import * class Application(Frame): def __init__(self,master=None,bgcolor=\u0026#34;#000000\u0026#34;): super().__init__() self.master = master self.bgcolor = bgcolor self.canvas = None self.fgcolor = \u0026#34;#ff0000\u0026#34; self.x = 0 self.y = 0 self.lastDraw = 0 self.startDrawFlag = False self.pack() self.createWedigt() def createWedigt(self): # 1. 创建画布，背景为黑色, self.canvas = Canvas(root,background=self.bgcolor,width=800,height=400) self.canvas.pack() # 2. 创建按钮 btn01 = Button(self, text=\u0026#34;开始\u0026#34;,name=\u0026#34;start\u0026#34;) btn01.pack(side=\u0026#34;left\u0026#34;,padx=5) btn02 = Button(self, text=\u0026#34;画笔\u0026#34;, name=\u0026#34;pen\u0026#34;) btn02.pack(side=\u0026#34;left\u0026#34;,padx=5) btn03 = Button(self, text=\u0026#34;画矩形\u0026#34;,name=\u0026#34;rect\u0026#34;) btn03.pack(side=\u0026#34;left\u0026#34;,padx=5) btn04 = Button(self, text=\u0026#34;清屏\u0026#34;,name=\u0026#34;clear\u0026#34; ) btn04.pack(side=\u0026#34;left\u0026#34;,padx=5) btn05 = Button(self, text=\u0026#34;橡皮檫\u0026#34;, name=\u0026#34;erasor\u0026#34;) btn05.pack(side=\u0026#34;left\u0026#34;,padx=5) btn06 = Button(self, text=\u0026#34;直线\u0026#34;, name=\u0026#34;line\u0026#34;) btn06.pack(side=\u0026#34;left\u0026#34;,padx=5) btn07 = Button(self, text=\u0026#34;直线（箭头）\u0026#34;, name=\u0026#34;lineArrow\u0026#34;) btn07.pack(side=\u0026#34;left\u0026#34;,padx=5) btn08 = Button(self, text=\u0026#34;颜色\u0026#34;,name=\u0026#34;color\u0026#34;) btn08.pack(side=\u0026#34;left\u0026#34;,padx=5) # 3 进行事件绑定！！ 注意看 btn02.bind_class(\u0026#34;Button\u0026#34;,\u0026#34;\u0026lt;Button-1\u0026gt;\u0026#34;,self.eventManager) self.canvas.bind(\u0026#34;\u0026lt;ButtonRelease-1\u0026gt;\u0026#34;,self.stopDraw) def eventManager(self,event): name = event.widget.winfo_name() print(name) if name == \u0026#34;line\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;,self.line) elif name == \u0026#34;lineArrow\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.linewithhead) elif name == \u0026#34;rect\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.rect) elif name == \u0026#34;pen\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.pen) elif name == \u0026#34;erasor\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.Erasor) elif name == \u0026#34;clear\u0026#34;: self.canvas.delete(\u0026#34;all\u0026#34;) elif name == \u0026#34;color\u0026#34;: c = askcolor(color=\u0026#34;black\u0026#34;, title=\u0026#34;选择画笔颜色\u0026#34;) self.fgcolor = c[1] elif name == \u0026#34;start\u0026#34;: messagebox.showinfo(\u0026#34;你好！\u0026#34;,\u0026#34;开始画画\u0026#34;) # 3 完成对应的操作 def stopDraw(self,event): print(\u0026#34;绘画结束\u0026#34;) self.startDrawFlag = False self.lastDraw = 0 def begin(self,event): self.canvas.delete(self.lastDraw) if not self.startDrawFlag: self.startDrawFlag = True self.x = event.x self.y = event.y def pen(self,event): self.begin(event) self.canvas.create_line(self.x,self.y,event.x,event.y,fill=self.fgcolor) self.x = event.x self.y = event.y def rect(self,event): self.begin(event) self.lastDraw = self.canvas.create_rectangle(self.x,self.y,event.x,event.y,outline=self.fgcolor) def Erasor(self,event): \u0026#34;\u0026#34;\u0026#34;其实就是线条白色\u0026#34;\u0026#34;\u0026#34; self.begin(event) self.canvas.create_rectangle(event.x-4,event.y-4,event.x,event.y,fill=self.bgcolor) self.x = event.x self.y = event.y def line(self,event): self.begin(event) # 以记录的xy 到当前鼠标的xy self.lastDraw = self.canvas.create_line(self.x,self.y,event.x,event.y,fill=self.fgcolor) def linewithhead(self,event): self.begin(event) self.lastDraw = self.canvas.create_line(self.x,self.y,event.x,event.y,arrow=LAST,fill= self.fgcolor) if __name__ == \u0026#39;__main__\u0026#39;: root = Tk() root.geometry(\u0026#34;800x500+100+200\u0026#34;) app = Application(root) root.mainloop() ","date":"2024-09-02T08:59:25+08:00","permalink":"http://localhost:1313/2024/imgs/","title":"GUI编程-画画坂"},{"content":"python网络编程 这也仅仅是python网络编程的入门，没有涉及到文件传输，也就是最基础的框架。UCP和TCP传输信息，并使用多线程进行双向通信。\npython也是socket套接字的编程。\n基础知识点 socket 套接字 socket 可以相当于是 “一次网络连接”\nsocket.socket([family[, type[, proto]]])\nfamily : 套接字家族可以使 AF_UNIX 或者 AF_INET ；\nAF 表示ADDRESS FAMILY 地址族 AF_INET（又称 PF_INET）是 IPv4 网络协议的套接字类型；而 AF_UNIX 则是 Unix 系统本地通信。\ntype : 套接字类型可以根据是面向连接的还是非连接分为 SOCK_STREAM 或 SOCK_DGRAM ； protocol : 一般不填，默认为0。\nsocket 基础的内置函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 s.bind() # 绑定地址到套接字上 s.listen() # 开启tcp监听 s.accept() # 被动接受客户端连接（阻塞） s.connect() # 客户端连接服务端 # 接受和发送信息 # 面向连接的，只有一个参数或返回值 s.send() s.recv() # 面对连接的，还需要多一个元组，表明目的IP地址和端口 s.sendto() s.recvfrom() # 这些仅是基础，后续需要用到再说。 了解了这些内置的函数，就可以进行UDP TCP 编程了。\nUDP UDP 面向无连接的传输。\n创建指定类型的socket对象 udp_socket = socket(AF_INET, SOCK_DGRAM)\nrecvfrom() 接受数据 sendto() 发送数据 recvfrom() 方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用 sendto() 就可以把数据用UDP发给客户端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 实现udp 双向通信，使用多线程，要注意端口号的设置（在本地测试的时候） # 导包 from socket import * from threading import Thread udp_socket = socket(AF_INET, SOCK_DGRAM) udp_socket.bind((\u0026#39;127.0.0.1\u0026#39;, 8888)) # 接受信息的端口 def recv_data(): while True: redata = udp_socket.recvfrom(1024) print(f\u0026#34;收到信息：{redata[0].decode(\u0026#39;gbk\u0026#39;)}from{redata[1]}\u0026#34;) def send_data(): while True: addr1 = (\u0026#39;127.0.0.1\u0026#39;, 9999) data = input(\u0026#34;请输入你要传输的数据：\u0026#34;) udp_socket.sendto(data.encode(\u0026#34;gbk\u0026#34;), addr1) if __name__ == \u0026#39;__main__\u0026#39;: t1 = Thread(target=recv_data) t2 = Thread(target=send_data) t2.start() t1.start() t1.join() t2.join() udp_socket.close() 需要注意的一点是：结束网络连接后，记得关闭socket\nTCP 面向连接的可靠传输\n需要区分服务端和客户端以其实现的功能。\n服务端：\n创建socket对象 绑定IP和端口 监听 发送接收信息 关闭socket 客户端：\n创建socket对象 连接到服务端socket 发送接收信息 关闭socket 以下是多线程实现双向通信\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 服务端 # 多线程的服务端 from socket import * from threading import Thread def recv_data(): while True: # 接受数据，接受到“end”就停止 redata = tcs.recv(1024).decode(\u0026#39;gbk\u0026#39;) print(f\u0026#34;客户端说：{redata}\u0026#34;) if redata == \u0026#34;end\u0026#34;: break def send_data(): while True: msg = input(\u0026#34;\u0026gt;\u0026#34;) tcs.send(msg.encode(\u0026#34;gbk\u0026#34;)) if __name__ == \u0026#39;__main__\u0026#39;: # 1 创建socket套接字 tss = socket(AF_INET, SOCK_STREAM) # 2 绑定信息 tss.bind((\u0026#39;127.0.0.1\u0026#39;, 8888)) # 3 监听端口 tss.listen() print(\u0026#34;等待客户端连接......\u0026#34;) # 等待客户端连接，注意这里的放回的是个元组！ tcs, host = tss.accept() print(\u0026#34;客户端连接成功，等待传输数据\u0026#34;) # 4 发送和接收信息 t1 = Thread(target=recv_data) t2 = Thread(target=send_data) t1.start() t2.start() t1.join() t2.join() # 关闭 tss.close() tcs.count() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 多线程的客户端 from socket import * from threading import Thread def recv_data(): while True: # 接受数据，接受到“end”就停止 redata = tcs.recv(1024).decode(\u0026#39;gbk\u0026#39;) print(f\u0026#34;服务说：{redata}\u0026#34;) def send_data(): while True: msg = input(\u0026#34;\u0026gt;\u0026#34;) tcs.send(msg.encode(\u0026#34;gbk\u0026#34;)) if msg == \u0026#34;end\u0026#34;: break if __name__ == \u0026#39;__main__\u0026#39;: # 1 创建socket对象 tcs = socket(AF_INET, SOCK_STREAM) # 2 连接服务端 tcs.connect((\u0026#39;127.0.0.1\u0026#39;, 8888)) print(\u0026#34;连接成功，\u0026#34;) # 3 发送和接收信息 t1 = Thread(target=recv_data) t2 = Thread(target=send_data) t2.start() t1.start() t1.join() t2.join() # 4 关闭socket tcs.close() 到此，最简单的python网络编程就实现了，后续再学习传输相关文件\n","date":"2024-07-29T18:04:15+08:00","permalink":"http://localhost:1313/2024/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-1/","title":"python网络编程入门-1"},{"content":"网络编程 看了狂神说Java的网络编程课程后进行总结。 但是关于 网络编程的知识不止这些，各种I/O的深入了解，不同需要的具体实现等等都需要后续的深入学习。\n基本概念 基于TCP协议实现C/S架构的通信。（打电话） 基于UDP协议实现B/S架构的通信。（发短信） **计算机网络：**把地理位置不同的多台设备，通过通信协议实现资源共享。\n目的：数据交换、通信\n需要解决的问题：\n如何定位电脑主机？ —IP+port 如何传输数据 ？ — socket + I/O 流+ 通信协议 下面就基于这两个问题进行学习。\n网络通信的要素 通过分析：\n需要知道通信双方的IP地址以及提供通信的端口。 需要明确通信协议 （TCP、UDP） 我们选择的编程语言为Java，需要理解 **Java“万物皆对象”**的特征。\nIP Java 提供了 一个 InetAddress类，表示Internet协议(IP)地址。\n从官方文档中，InetAddress类并没有构造器，因此无法使用new 创建对象。（但是又静态方法。）\n以下为 构造InetAddress对象以及其常用方法。\n1 2 3 4 5 6 7 8 9 10 11 12 public class IpTest { public static void main(String[] args) throws UnknownHostException { // 使用静态方法 getByName() 构造对象，参数为 域名 或 IP地址 InetAddress inetaddress1 = InetAddress.getByName(\u0026#34;www.baidu.com\u0026#34;); System.out.println(inetaddress1); //打印主机地址 System.out.println(inetaddress1.getHostAddress()); //获取主机名 System.out.println(inetaddress1.getHostName()); } port 端口可以认为是设备与外界通讯交流的出口。也表示进程占用。\n大致分类：\n0-1023 公有端口。 如: HTTP 80 HTTPS 443 FTP 21 Telent 23 SSH 22 1024-19151 程序 19152-65535 动态私有 查看相关端口的命令：\n1 2 3 4 //查看端口占用 netsata -ano |find \u0026#34;xxx\u0026#34; //任务管理器 tasklist 通信协议： 为传输层协议，网络编程中使用实时连接TCP和无连接UDP。\n详细的就不在此赘述了。\n实现TCP实时连接 需要构造客户端、服务端。\n涉及到的类： InetAddress获取IP对象。\nsocket套接字：双方进行通信的一个抽象端口。\nI/O流：用于数据传输。\ngetBytes() 方法：将字符串转化为Byte序列，供以进行流传输。\n客户端 明确服务端的IP及端口 创建一个套接字地址 通过I/O传输数据(byte) 关闭资源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //客户端 public class tcpclinet { public static void main(String[] args) throws IOException { // id InetAddress inet = InetAddress.getByName(\u0026#34;127.0.0.1\u0026#34;); //port int port = 9999; //创建一个scoket地址 Socket socket = new Socket(inet, port); //发送信息，输出流 OutputStream os = socket.getOutputStream(); //这是是写出 btye 数据 os.write(\u0026#34;你好\u0026#34;.getBytes()); os.close(); } } 服务端 创建serverSocket套接字 等待客户端连接 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Tcpserver { public static void main(String[] args) throws IOException { // serversocket ServerSocket serverSocket = new ServerSocket(9999); // 等待连接 Socket accept = serverSocket.accept(); System.out.println(\u0026#34;连接成功\u0026#34;); // 读取客户端信息 InputStream is = accept.getInputStream(); // 管道流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer = new byte[4096]; int len ; while((len= is.read(buffer))!= -1 ) { baos.write(buffer,0,len); } System.out.println(baos.toString()); } } 实现TCP 发送文件 客户端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class ClientTest { public static void main(String[] args) throws IOException { Socket s = new Socket(\u0026#34;127.0.0.1\u0026#34;,8888); System.out.println(\u0026#34;客户端启动！准备接受文件！\u0026#34;); //数据输入流 DataInputStream dis = new DataInputStream(s.getInputStream()); //接收文件数量 int fileCount = dis.readInt(); System.out.println(\u0026#34;需要接收的文件个数：\u0026#34;+fileCount); //下载多少个文件 for (int i = 0; i \u0026lt; fileCount; i++) { //名字和长度 String fileName = dis.readUTF(); long fileSize = dis.readLong(); //利用文件输出流，创建文件 FileOutputStream fos = new FileOutputStream(\u0026#34;received_\u0026#34; + fileName); byte[] buffer = new byte[4096]; int bytesRead; long totalBytesRead = 0; while ((bytesRead = dis.read(buffer)) != -1) { fos.write(buffer,0,bytesRead); totalBytesRead +=bytesRead; if(totalBytesRead == fileSize) { break; } } System.out.println(\u0026#34;已接收文件：\u0026#34;+fileName); fos.close(); } dis.close(); s.close(); } } 服务端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 public class ServerTest { public static void main(String[] args) throws IOException { //开放8888端口 ServerSocket ss = new ServerSocket(8888); System.out.println(\u0026#34;服务端等待连接。。。。\u0026#34;); //客服端连接 Socket s = ss.accept(); OutputStream os = s.getOutputStream(); DataOutputStream dos = new DataOutputStream(s.getOutputStream()); System.out.println(\u0026#34;连接成功！传输文件\u0026#34;); //读取本地的多个文件 ,存放在一个数组里。 File File = new File(\u0026#34;./files\u0026#34;); File[] files = File.listFiles(); assert files != null; int len = files.length; //需要先发送文件的信息,文件数量 dos.writeInt(len); dos.flush(); //发送每个文件 for (java.io.File file : files) { //文件输入流。 FileInputStream fis = new FileInputStream(file); //获取文件的名字和长度 String fileName = file.getName(); long fileSize = file.length(); //把名字和长度传过去 dos.writeUTF(fileName); dos.writeLong(fileSize); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = fis.read(buffer)) != -1) { dos.write(buffer, 0, bytesRead); } fis.close(); System.out.println(\u0026#34;已发送文件：\u0026#34;+fileName); } //现在有思路是服务端就这样写，然后客户端创建对应的名字进行存储，应该考虑大小问题。 dos.close(); //多个文件传输 //FileInputStream file = new FileInputStream(files[0]); } } 实现UDP发送信息 UDP 协议则需要使用到 DatagramSocket 套接字 和 DatagramPacket 类。\n基本框架是：\n创建DatagramSocket套接字 创建packet 发送packet 发送端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Udpclient { public static void main(String[] args) throws IOException { // socket DatagramSocket socket = new DatagramSocket(); // creat packet String msg = \u0026#34;你好啊，服务器！\u0026#34;; InetAddress serverip = InetAddress.getByName(\u0026#34;127.0.0.1\u0026#34;); int port = 9999; //数据 ，发送给谁 5个参数 //将字符串编码为 byte 序列，并将结果存储到一个新的 byte 数组中 DatagramPacket packet = new DatagramPacket(msg.getBytes(), 0, msg.getBytes().length, serverip, port); // 发送包 socket.send(packet); socket.close(); } } 接受端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class udpserver { public static void main(String[] args) throws IOException { // 开放端口 DatagramSocket socket = new DatagramSocket(9999); // 接受数据 byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length); socket.receive(packet); System.out.println(packet.getAddress().getHostAddress()); System.out.println(new String(packet.getData(), 0, packet.getLength())); } } 至此实现了基础的发送信息。也可以优化成连续不断发送信息直到 ，发送方停止。\n只需要把对应的代码放入 while循环中，再通过添加终止条件，达到目的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ublic class UdpSender { public static void main(String[] args) throws IOException { DatagramSocket socket = new DatagramSocket(6666); BufferedReader render = new BufferedReader(new InputStreamReader(System.in)); while(true) { String data = render.readLine(); //处理字符串封装成包 byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(\u0026#34;127.0.0.1\u0026#34;,8888)); socket.send(packet); if(data.equals(\u0026#34;bye\u0026#34;)) { break; } } //发送的数据，从键盘获取 socket.close(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class UdpReceive { public static void main(String[] args) throws IOException { DatagramSocket socket = new DatagramSocket(8888); while(true) { byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length); socket.receive(packet); byte[] data = packet.getData(); String recevedata = new String(data,0, packet.getLength()); System.out.println(recevedata); if (recevedata.equals(\u0026#34;bye\u0026#34;)) { break; } } } } 在实现该功能时，遇到了一些问题:\nQ：在接受端，接受的数据长度很长。\n1 2 3 4 5 6 7 //错误代码 byte[] data = packet.getData(); String recevedata = new String(data,0, data.Lenth); //但是 data.Lenth的值为 1024 （发送端的数据长度），并不是发送过来的实际长度。 //实际长度应为 packet.getLenth() String recevedata = new String(data,0, packet.getLength()); 实现UDP聊天实现 要实现聊天的实现，就得学习Java 多线程，使得双方可以互相发送信息。\n需要 将 发送端以及接受端写入线程中。\n发送端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class TalkSent implements Runnable{ // 成员 DatagramSocket socket =null; BufferedReader render = null; private int fromprot; private String toip; private int toport; // 初始化进程 public TalkSent(int fromprot, String toip, int toport) { this.fromprot = fromprot; this.toip = toip; this.toport = toport; } // 子线程运行的内容 @Override public void run() { try { socket = new DatagramSocket(fromprot); render = new BufferedReader(new InputStreamReader(System.in)); while(true) { String data = render.readLine(); //处理字符串封装成包 byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(this.toip,this.toport)); socket.send(packet); if(data.equals(\u0026#34;bye\u0026#34;)) { break; } } } catch (Exception e) { throw new RuntimeException(e); } socket.close(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class TalkReceive implements Runnable{ DatagramSocket socket=null; private int fromPort; private String msgFrom; public TalkReceive(int fromPort,String msgFrom) throws SocketException { this.fromPort = fromPort; this.msgFrom = msgFrom; socket = new DatagramSocket(this.fromPort); } @Override public void run() { try { while(true) { byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length); socket.receive(packet); byte[] data = packet.getData(); // 为什么这里出错了,长度为为 1024 . String recevedata = new String(data,0, packet.getLength()); System.out.println(msgFrom+\u0026#34;:\u0026#34;+recevedata); if (recevedata.equals(\u0026#34;bye\u0026#34;)) { break; } } } catch (Exception e) { throw new RuntimeException(e); } } } 实现了这个对于 通信双方就容易了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class TalkStudent { public static void main(String[] args) throws SocketException { //开启两个线程 //发送到目标主机的9999端口 new Thread(new TalkSent(7777,\u0026#34;localhost\u0026#34;,9999)).start(); //接受来自 8888 端口的信息 。 new Thread(new TalkReceive(8888,\u0026#34;老师\u0026#34;)).start(); } } public class TalkTecher { public static void main(String[] args) throws SocketException { //发送到目标主机的8888端口 new Thread(new TalkSent(5555,\u0026#34;127.0.0.1\u0026#34;,8888)).start(); //接收9999端口的信息 new Thread(new TalkReceive(9999,\u0026#34;学生\u0026#34;)).start(); } } URL资源下载 需要用到 URL 类 以及 进行HttpURLconnection 网络连接。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class urlTest { public static void main(String[] args) throws IOException { URL url = new URL(\u0026#34;https://img3.doubanio.com/dae/accounts/resources/ded47ae/movie/assets/annual_2023.png\u0026#34;); // 进行 http连接 URLConnection connection = url.openConnection(); //HttpURLconnection urlconnection =(HttpURLconnection)url.openconnection(); // 输入流 InputStream is = connection.getInputStream(); System.out.println(connection); // 文件输出流，把文件保留在本地 FileOutputStream fos = new FileOutputStream(\u0026#34;a.png\u0026#34;); byte[] buffer = new byte[1024]; int len ; while((len=is.read(buffer))!= -1) { fos.write(buffer,0,len); } fos.close(); is.close(); } } ","date":"2024-04-23T23:08:18+08:00","permalink":"http://localhost:1313/2024/imgs/","title":"网络编程基础入门"},{"content":"hugo+stack 本主题由 CaiJimmy 制作并发布，这个仓库是由 Mantyke 修改的魔改版本\nGithub 仓库地址：Mantyke/stack-theme-mod\n参考文章：https://cuttontail.blog/blog/create-a-wesite-using-github-pages-and-hugo/（师傅写得很详细，我就不再赘述。）\n思路：GitHub pages + hugo 进行搭建博客。\n不过在途中遇到一些问题：hugo server 时总是报错，因此决定采取更加容易的搭建方式。\n可能原因是：\n主题模板与hugo 版本不适配。 模板中post文章的语法出错。 hugo 根据Hugo 文档：Install Hugo去安装hugo。\n1 2 #检查是否安装成功（extend版） hugo version stack 在项目目录下:(把Mantyke师傅的版本直接git到本地)\n1 git clone https://github.com/Mantyke/Hugo-stack-theme-mod.git 不再使用 hugo new site xxxx创建网点的方式进行搭建。\nGitHub pages 这个仓库必须使用特殊的命名格式 \u0026lt;username.github.io\u0026gt;， \u0026lt;username\u0026gt; 是自己的 GitHub 的用户名。\n发布 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #生成静态网页到public hugo #将 public 文件夹初始化为 Git 仓库，并设置默认主分支名为 main。 cd public git init -b main #需要设置 GitHub 的 ssh 链接 git remote add origin git@github.com:Rosewwwfr/Rosewwwfr.github.io.git git pull --rebase origin main git add . git commit -m \u0026#34;...(修改的信息)\u0026#34; git push origin main 后续管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #创建文章 hugo new xxx.md #本地调试 hugo server #生成html hugo #上传到GitHub pages git add . git commit -m \u0026#34;...(修改的信息)\u0026#34; git pull --rebase origin main #可选,如果远端仓库与本地一致，则不需要合并。 git push origin main 刚开始可以手动发布，后续学习 gitthub action 自动发布。\n相关配置 可以参考：官网的配置,写的十分清楚。\nhttps://mantyke.icu/posts/2022/stack-theme-mod/\n修改了一个实现分类双栏的效果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //-------------------------------------------------- // 文件位置：~/assets/scss/custom/_custom.scss /* 归档页面两栏 */ @media (min-width: 1024px) { .article-list--compact { display: grid; grid-template-columns: 1fr 1fr; background: none; box-shadow: none; gap: 1rem; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; border-radius: 16px; } } } 利用GitHub搭建简易图床 博客肯定少不了图片，手动上传就麻烦了一点，于是学一下搭建免费简易图床。参考\nGitHub 创建仓库 创建GitHub token 在 picgo 上设置。 image-20240410143656485\r在typroa 上设置 上传图片，方便写博客。\nimage-20240410143812940\r（先试试效果怎么样，不行再换）\n到此，博客已经可以开始使用了，后续无聊在进行改动。\n参考文章： pesudoyu师傅 cuttontail师傅\nhttps://stack.jimmycai.com/config/\n利用GitHub搭建免费图床\n","date":"2024-04-09T10:17:45+08:00","permalink":"http://localhost:1313/2024/hugo-stack%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/","title":"【hugo+stack】搭建过程"},{"content":"","date":"2024-04-09T09:15:49+08:00","permalink":"http://localhost:1313/2024/hello-world/","title":"Hello World！"}]