[{"content":"Mybatisplus 再学习 前言：\n本文对代码生成器、多数据源、mybatisx插件作了简单介绍。\n其官网均有对应的内容，作为新手的我阅读起来有点困难，希望本文能帮助读者进行理解。\n代码生成器：https://baomidou.com/guides/code-generator/\n多数据源支持；https://baomidou.com/guides/dynamic-datasource/\nmybatisx:https://baomidou.com/guides/mybatis-x/\n代码生成器 代码生成器：顾名思义，就是根据数据库表帮我们生成实体类、MVC三层模型的基础CURD，大大简化了开发。）\nmybatis-plus-generator 3.5.1以下版本：为旧版本的代码生成器。可以自行查阅官网。\n详细经过以下案例，你对对代码生成器会有一定了解的。\n使用案例： 依赖：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-generator\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 代码生成的模板框架：\nimage-20241211141755550\r1 2 3 4 5 6 \u0026lt;!-- 这个是代码生成的模板框架--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.freemarker\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;freemarker\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.31\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 编写代码生成器： 有快速生成和交互式生成的方法。这里就演示快速生成。\n在对应的包下创建代码生成类：\nimage-20241211142053680\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package top.rose.mpgender; import com.baomidou.mybatisplus.generator.FastAutoGenerator; import com.baomidou.mybatisplus.generator.config.OutputFile; import com.baomidou.mybatisplus.generator.config.rules.DbColumnType; import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine; import java.sql.Types; import java.util.Collections; /** * @ author: rose * @ date: 2024-12-11 * @ version: 1.0 * @ description: 简单的代码生成器的使用案例。 */ public class generator { public static void main(String[] args) { // 1 编写输出的路径，可以不用修改 final String OUTPUTPATH=System.getProperty(\u0026#34;user.dir\u0026#34;)+\u0026#34;\\\\src\\\\main\\\\java\u0026#34;; final String XMLOUTPUTPATH=System.getProperty(\u0026#34;user.dir\u0026#34;)+\u0026#34;\\\\src\\\\main\\\\resources\\\\mapper\\\\\u0026#34;; // 2 这里填写连接信息 FastAutoGenerator.create(\u0026#34;jdbc:mysql://localhost:3306/personal_health?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;serverTimezone=UTC\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;) .globalConfig(builder -\u0026gt; { builder.author(\u0026#34;rose\u0026#34;) // 设置作者 .outputDir(OUTPUTPATH); // 指定输出目录 }) .dataSourceConfig(builder -\u0026gt; builder.typeConvertHandler((globalConfig, typeRegistry, metaInfo) -\u0026gt; { int typeCode = metaInfo.getJdbcType().TYPE_CODE; if (typeCode == Types.SMALLINT) { // 自定义类型转换 return DbColumnType.INTEGER; } return typeRegistry.getColumnType(metaInfo); }) ) // 3 设置模板名和 xml文件位置 .packageConfig(builder -\u0026gt; builder.parent(\u0026#34;top.rose\u0026#34;) // 设置父包名 .moduleName(\u0026#34;mp\u0026#34;) // 设置父包模块名 .pathInfo(Collections.singletonMap(OutputFile.xml, XMLOUTPUTPATH)) // 设置mapperXml生成路径 ) // 4 指定要生成的表，以及设置需要去掉的前缀 .strategyConfig(builder -\u0026gt; builder.addInclude(\u0026#34;user\u0026#34;) // 设置需要生成的表名 .addTablePrefix(\u0026#34;user_\u0026#34;) // 设置过滤表前缀 ) // 5 设置使用的模板引擎 .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute(); } } 运行-生成代码 运行过后，就会生成对应的三层架构以及实体类。\nimage-20241211142616070\r注意：案例中 生成的代码不是和 启动类在一个包中的，实际使用时要设置为同一个包。\n至此，一个简单的代码生成器案例就结束了，深入学习，查看官网，相信这个时候，已经能看到官网是什么意思了。\n还可以深入了解其各个配置的使用场景。\n多数据源 适用于多种场景：纯粹多库、 读写分离、 一主多从、 混合模式等\n这里简单说明一下，多库的使用。\n导入依赖：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dynamic-datasource-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置多数据源\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 spring: # 配置数据源信息 datasource: dynamic: # 设置默认的数据源或者数据源组,默认值即为master primary: master # 严格匹配数据源,默认false.true未匹配到指定数据源时抛异常,false使用默认数据源 strict: false datasource: master: url: jdbc:mysql://localhost:3306/mp?characterEncoding=utf-8\u0026amp;useSSL=false driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 123456 slave_1: url: jdbc:mysql://localhost:3306/mp1?characterEncoding=utf-8\u0026amp;useSSL=false driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 123456 最后，要使用哪个库就添加上 @DS(\u0026quot;slave_1\u0026quot;)注解 指定所操作的数据源\nMybatisX 一些复杂的SQL，多表联查，就需要自己去编写代码和SQL语句，这个时候可以使用MyBatisX插件.\nMyBatisX一款基于 IDEA 的快速开发插件，为效率而生\n官方地址：MybatisX快速开发插件 | MyBatis-Plus (baomidou.com)\n安装MybatisX插件 File -\u0026gt; Settings -\u0026gt; Plugins -\u0026gt; Browse Repositories\n在idea中的插件中搜索进行下载安装。\n核心功能 xml 跳转 点击mapper中方法 前面的蓝色小鸟，即可一键跳转到对应的xml映射。\nimage-20241211144303213\r代码快速生成 也就是对应其前面的代码生成器。\nimage-20241211144922450\r编写对应的信息；（基础包、忽略前缀、忽略后缀等等）\n设置注解 、组件、生成模板、生成位置等等。\nimage-20241211145255891\r效果与代码生成器一致。\n快速生成CURD 当你自定义编写mapper方法时，可以alt+enter 选择快速生成映射。 image-20241211144555948\r快速生成基础的CURD 。例如输入 insert 会提示出 insertxxxx,可以进行选择一键生成。（其他的类似）\rimage-20241211144737892\r参考： hua师傅: https://blog.csdn.net/weixin_49001740/article/details/123986857\n","date":"2024-12-11T14:55:30+08:00","permalink":"http://localhost:1313/2024/mp%E5%86%8D%E5%AD%A6%E4%B9%A0-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90mybatisx%E6%8F%92%E4%BB%B6/","title":"mp再学习- 代码生成器、多数据源、mybatisX插件"},{"content":"常用插件 分页器插件 分页查询是开发过程中很常见的一个功能。mp 提供了该插件进行简化开发。\n基础使用 新建MybatisPlusConfig配置类(官网) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Configuration @MapperScan(\u0026#34;scan.your.mapper.package\u0026#34;) public class MybatisPlusConfig { /** * 添加分页插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); // 如果配置多个插件, 切记分页最后添加 // 如果有多数据源可以不配具体类型, 否则都建议配上具体的 DbType interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } 属性介绍:\nimage-20241210154454397\r通过使用 selectPage方法进行基础的查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Test void testPage(){ // 测试分页器 // 创建一个page对象。设置参数，当前页，每页显示条数 Page\u0026lt;Tags\u0026gt; page = new Page\u0026lt;\u0026gt;(1, 3); // 查询的结果会存储到page对象中。第二个参数是条件构造器 tagMapper.selectPage(page,null); List\u0026lt;Tags\u0026gt; records = page.getRecords(); // 遍历结果 records.forEach(System.out::println); // 也有一些其他参数 page.getRecords(); page.getTotal(); page.getCurrent(); page.getSize(); page.getPages(); page.hasNext(); page.hasPrevious(); } 也可以自定义Mapper通常是一下方法：(Page 继承与Ipage) selectPageVO 1 2 3 4 5 IPage\u0026lt;UserVo\u0026gt; selectPageVo(IPage\u0026lt;?\u0026gt; page, Integer state); // 或者自定义分页类 MyPage selectPageVo(MyPage page); // 或者返回 List List\u0026lt;UserVo\u0026gt; selectPageVo(IPage\u0026lt;UserVo\u0026gt; page, Integer state); 对应的XML配置：\n1 2 3 \u0026lt;select id=\u0026#34;selectPageVo\u0026#34; resultType=\u0026#34;xxx.xxx.xxx.UserVo\u0026#34;\u0026gt; SELECT id,name FROM user WHERE state=#{state} \u0026lt;/select\u0026gt; 案例：实际使用（其实自定义个方法同名方法,自定义返回类型等等）\n1 2 3 4 5 6 7 @Mapper public interface TagMapper extends BaseMapper\u0026lt;Tags\u0026gt; { List\u0026lt;Tags\u0026gt; selectPageVO( Page\u0026lt;Tags\u0026gt; page, Integer id // 这个是设置自定义条件的。 ); } 1 2 3 4 5 \u0026lt;mapper namespace=\u0026#34;top.rose.health.mapper.TagMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;selectPageVO\u0026#34; resultType=\u0026#34;top.rose.health.entity.Tags\u0026#34;\u0026gt; select * from tags where id \u0026gt; #{id}; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 测试：\n1 2 3 4 5 6 7 8 9 10 @Test void testPageVO() { // 测试自定义分页器 Page\u0026lt;Tags\u0026gt; page = new Page\u0026lt;\u0026gt;(1, 3); // 查询id大于2的进行分页 List\u0026lt;Tags\u0026gt; records = tagMapper.selectPageVO(page, 2); // 遍历结果 records.forEach(System.out::println); System.out.println(\u0026#34;测试结束！\u0026#34;); } 结果：\rimage-20241210165020252\r补充 - Page类 Page 类继承了 IPage 类，实现了简单分页模型。如果你需要实现自己的分页模型，可以继承 Page 类或实现 IPage 类。\nimage-20241210165304596\r乐观锁插件 简单来说：就是为了解决同时对数据库操作冲突的。\n举例：一件物品100元，A、B 同时修改价格，A、B取出100，A操作得快，100-10 = 90 ，保存到数据库。B操作得慢，100+10 =110.保存到数据库。由于没有锁，因此110 覆盖掉 90.\n解决方案：上锁\u0026ndash; 乐观锁、悲观锁\n乐观锁：保存之前，查询数据是否被修改，修改了则重新进行操作再保存。\n悲观锁：只有等其他人操作结束后，才能对数据进行操作。\n乐观锁实现方案： 数据库表添加一个version字段 取出数据时，记录下version 更新时 version +1 ，如果和数据库表中version不同则修改失败 使用 实体类中添加@Version 标识乐观锁版本号字段 MybatisPlusConfig配置类中添加乐观锁插件配置 1 2 3 4 5 6 7 8 9 10 11 @Configuration @MapperScan(\u0026#34;com.yourpackage.mapper\u0026#34;) public class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return interceptor; } } ","date":"2024-12-10T17:11:30+08:00","permalink":"http://localhost:1313/2024/mp%E6%8F%92%E4%BB%B6-%E5%88%86%E9%A1%B5%E5%99%A8%E4%B9%90%E8%A7%82%E9%94%81/","title":"mp插件-分页器、乐观锁"},{"content":"Mybatis Plus -1 写在前面：\n介绍了mp的基础使用方法，看完即可简化mybatis的开发，实现一些初学阶段的curd\n对于复杂情况的curd，可以对官网进行查阅，不断进行积累经验。\nhttps://baomidou.com/getting-started/\n一个 MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生\n支持任何能使用 Mybatis 进行 CRUD, 并且支持标准 SQL 的数据库。\n官网：https://baomidou.com/\n简单来说：就是简化mybatis的开发，内置了一些sql，不用每个CURD都手写。\n入门案例 BaseMapper是MyBatis-Plus提供的模板mapper。\n我们创建操作对应数据库的mapper 后，继承BaseMapper 即可。\n1 2 @Mapper public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt;{} 记得添加 @Mapper 或在启动类添加 @MapperScan 指定对应的mapper，使其交给IOC容器管理。\n测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @SpringBootTest class MybatisPlusDemoApplicationTests { // 自动从IOC容器中装载对应的对象 @Autowired private UserMapper userMapper; @Test public void testSelectList(){ //UserMapper 中的 selectList() 方法的参数为 MP 内置的条件封装器 Wrapper //所以不填写就是无任何条件 List\u0026lt;User\u0026gt; users = userMapper.selectList(null); users.forEach(user -\u0026gt; System.out.println(user)); } } tips: 开启日志输出,输出在控制台。 方便检查sql 的执行情况以及找出错误。\n1 2 #mybatis日志 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 基本的CURD 最基础的增删改查，在baseMapper中均已定义，可以直接使用。\ninsert 没什么好说的，传入一个实体类就会插入。返回受影响的行数。\n1 int rangs = userMapper.insert(user); 值得一说的是：其id 策略默认是 基于雪花算法生成的。（可以在实体类中通过注解修改，或进行配置）\ndelete deleteById deleteBatchIds deleteByMap 可以为删除设置条件。 Update updateById 需要传入一个有id值的实体类对象。\nSelect selectById selectBatchIds selectByMap selectList 查询所有信息 BaseMapper中大多方法中都有Wrapper类型的形参，此为条件构造器\n可针对于SQL语句设置不同的条件，若没有条件赋值null，即查询（删除/修改）所有数据\n自定义功能 是对mybatis的增强，因此也可以自定义sql语句，创建对应的映射文件。\n同包同名 resource下 namspace属性 \u0026mdash; mapper的全类名 id属性 \u0026mdash; 方法名 通用service - iservice image-20241209185610595\rservice 接口继承 iservice\n1 public interface UserService extends iservice\u0026lt;User\u0026gt;{} service接口\n1 2 public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; implements UserService { } 就可以使用内置的方法了。见官网。\n常用注解： @tableName 解决实体类名和数据库表名不同。 也可以通过全局配置解决\n@tableId: 解决属性名和数据库表id名不同。\n如果表中的id名不为id 需用 value属性进行指定。type属性，指定主键策略。\ndType.ASSIGN_ID(默认)：基于雪花算法的策略生成数据id，与数据库id是否设置自增无关 IdType.AUTO：使用数据库的自增策略，要确保数据库设置了id自增， 否则无效 也可以全局配置：\n1 2 # 配置MyBatis-Plus的主键策略 mybatis-plus.global-config.db-config.id-type=auto @tableField: 解决属性名和列名不同。\n实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格\n如实体类属性userName，表中字段user_name\n此时MyBatis-Plus会自动将下划线命名风格转化为驼峰命名风格，相当于在MyBatis中配置\n如果是单纯的不一样，则需要通过该注解指定。\n@TableLogic : 逻辑删除\n表中有字段 is_delete, 如果执行了 delete 操作，就会将字段转化为0，而不是真的删除。\n（例如回收站，可以恢复数据）\n条件构造器和通用接口 字面意思：构造CURD的条件，搭配baseMapper 中的方法进行使用。\nwrapper Wrapper ： 条件构造抽象类，最顶端父类 AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件 QueryWrapper ： 查询条件封装 UpdateWrapper ： Update 条件封装 AbstractLambdaWrapper ： 使用Lambda 语法 LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper LambdaUpdateWrapper ： Lambda 更新封装Wrapper\n使用 1 2 3 4 5 6 7 // 1 创建一个 wrapper 对象 QueryWrapper\u0026lt;User\u0026gt; queryWrapper = new QueryWrapper\u0026lt;\u0026gt;(); // 2 条件构造 queryWrapper.like(\u0026#34;name\u0026#34;,\u0026#34;a\u0026#34;) .gt(\u0026#34;age\u0026#34;,20); // 3 作为参数传递 userMapper.update(user,queryWrapper); 具体的可以参考官网： https://baomidou.com/guides/wrapper/\n也就是构造自己想要的条件，需要什么去官网找（或者在idea中看源码）。用多了自然就会了。\nCondition: 在开发过程中，组装条件是常见的功能，而这些条件数据来源于用户输入，是可选的，因此我们在组装这些条件时，必须先判断用户是否选择了这些条件，若选择则需要组装该条件，若没有选择则一定不能组装，以免影响SQL执行的结果。\n思路1: 可以用 if 语句进行判断。但是太冗余了。\n思路2：使用带condition参数的重载方法构建查 询条件，简化代码的编写。\n1 queryWrapper.like(StringUtils.isBlank(username),\u0026#34;name\u0026#34;,\u0026#34;a\u0026#34;); 通过Lambda访问实体类属性对应的字段，避免使用字符串表示字段，防止运行时错误\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //组装set子句 //将用户名中包含有a并且（年龄小于24或邮箱为null）的用户信息修改 LambdaUpdateWrapper\u0026lt;User\u0026gt; updateWrapper = new LambdaUpdateWrapper\u0026lt;\u0026gt;(); updateWrapper //Lambda表达式设置操作字段 .set(User::getAge, 18) .set(User::getEmail, \u0026#34;user@test11.com\u0026#34;) .like(User::getName, \u0026#34;a\u0026#34;) //lambda表达式内的逻辑优先运算 .and(i -\u0026gt; i.lt(User::getAge, 24).or().isNull(User::getEmail)); User user = new User(); int result = userMapper.update(user, updateWrapper); 还可以对分页插件、乐观锁等插件、通用枚举、代码生成器、多数据源和MybatisX 进行学习.\n","date":"2024-12-09T19:24:30+08:00","permalink":"http://localhost:1313/2024/mybatis-plus%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-1/","title":"Mybatis Plus入门学习-1"},{"content":"Springboot3x 脚手架开发-整合登录注册 先理清要实现的功能\n登录：\n用户、密码、验证码\n注册\n用户、密码、邮箱、邮箱验证码\n因此就需要知道 如何引入图形验证码、短信验证码 （还有模板优化）\n图形验证码接口 接口介绍：/captchCode\n当用户要登录的时候（即访问 /login时），自动调用该接口。返回验证码ID和验证码图片的base64编码。\n前端保存该id，显示图片，把用户输入的验证码和验证码id一并提交到表单，在后端进行校验（校验验证码和账密码）。\n先定义验证码接口数据对象\n1 2 3 4 5 6 7 8 @Data @Builder public class CaptchaVO { //验证码id private String captchaId; //验证码图片base64编码 private String captchaImage; } 实现接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @RestController @RequestMapping(\u0026#34;/captcha\u0026#34;) @Tag(name = \u0026#34;验证码接口\u0026#34; ,description = \u0026#34;验证码接口相关操作\u0026#34;) public class CaptchaController { // 导入 redis private final StringRedisTemplate stringRedisTemplate; public CaptchaController(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } @GetMapping @Operation(summary = \u0026#34;获取验证码\u0026#34;) public CaptchaVO getCaptcha(String captchaId) { // 利用 hutoll 的工具获取验证码， 设置高度宽度（应该与前端一致） 位数 和干扰线 CircleCaptcha circleCaptcha = CaptchaUtil.createCircleCaptcha(130,50,4,10); // 获取文本 String code = circleCaptcha.getCode(); // 获取图片base64 String imageBase64Data = circleCaptcha.getImageBase64Data(); // 如果没有传入id 则生成一个随机字符串作为id uuid captchaId = Optional.ofNullable(captchaId).orElseGet(() -\u0026gt; UUID.randomUUID().toString()); // 保存到 redis中 并设置有效期为 30分钟 stringRedisTemplate.opsForValue().set(\u0026#34;captcha:\u0026#34;+captchaId,imageBase64Data,30, TimeUnit.MINUTES); // 返回对象给前端 return CaptchaVO.builder() .captchaId(captchaId) .captchaImage(imageBase64Data) .build(); } } 邮件发送验证码接口 接口介绍：接收前端的邮箱，对指定邮箱发送验证码。\n准备： 需要准备一个邮箱开启 POP3/SMTP服务，用于发送邮件。（qq邮箱）\nimage-20241203170124960\r开启后有个授权码（需要记住）\n导入依赖：\n1 2 3 4 5 6 7 8 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-mail\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; application.yml 配置相关信息\n1 2 3 4 5 6 7 8 9 10 11 12 mail: host: smtp.qq.com protocol: smtp username: 1320104286@qq.com password: dbamnosrjtwaibif default-encoding: utf-8 properties: mail.smtp.auth: true mail.smtp.starttls.enable: true main: allow-bean-definition-overriding: true allow-circular-references: true 创建接收邮箱的数据对象\n1 2 3 4 5 @Data public class EmailDto { @NotBlank private String email; } 一个获取验证码的RandomUtil\n1 2 3 4 5 6 7 8 9 10 11 12 public class RandomUtil { public static String getSixRandomCode() { // 获取6位随机数字作为验证码 Random random = new Random(); StringBuilder code = new StringBuilder(); for (int i = 0; i \u0026lt; 6; i++) { code.append(random.nextInt(10)); } return code.toString(); } } 编写邮件发送模板：在网上找到心仪的即可，也可以自己写。(存放在resources下的template)\n编写邮件发送服务:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @Service @Slf4j public class EmailServiceImpl implements EmailService { private final StringRedisTemplate stringRedisTemplate; @Autowired private JavaMailSenderImpl mailSender; // 自动装配邮件发送器 @Autowired private TemplateEngine templateEngine; // 自动装配模板引擎 // 构造函数注入StringRedisTemplate public EmailServiceImpl(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } /** * 发送带有验证码的邮件 * @param emailDto 包含收件人邮箱和可能的其他邮件信息的DTO对象 */ @Override public void sendEmail(EmailDto emailDto) { String email = emailDto.getEmail(); // 获取收件人邮箱 String code = RandomUtil.getSixRandomCode(); // 生成六位随机验证码 String subject = \u0026#34;模版验证码\u0026#34;; // 邮件主题 // 将生成的验证码存储到redis中,有效期为15分钟 stringRedisTemplate.opsForValue().set(\u0026#34;verifycode:\u0026#34;+email,code,5, TimeUnit.MINUTES); // 将内容设置为模板 Context context = new Context(); // 将验证码分割成一个个字符 context.setVariable(\u0026#34;verifyCode\u0026#34;, Arrays.asList(code.split(\u0026#34;\u0026#34;))); // 加载模板并处理, 改文件名不需要写全类名。 String process = templateEngine.process(\u0026#34;EmailVerificationCode.html\u0026#34;,context); MimeMessage mimeMessage = mailSender.createMimeMessage(); try{ MimeMessageHelper helper = new MimeMessageHelper(mimeMessage); helper.setFrom(\u0026#34;1320104286@qq.com\u0026#34;); // 设置发件人邮箱 helper.setTo(email); // 设置收件人邮箱 helper.setSubject(subject); // 设置邮件主题 helper.setSentDate(new Date()); // 设置发送日期 helper.setText(process,true); // 设置邮件内容为HTML格式 // true 表示加载为html } catch (Exception e) { throw new RuntimeException(e); // 发生异常时抛出运行时异常 } mailSender.send(mimeMessage); // 发送邮件 log.info(\u0026#34;发送成功！\u0026#34;); // 记录日志，表示邮件发送成功 } } 到此邮件发送的服务就已经实现了。\n登录接口 只需要账号、密码、图形验证码即可成功登录。\n在数据库中查用户，设置jwt，存放到redis中，并把用户信息存放到本地线程\n准备工作： 设计数据库表（按你自己的需求来）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 create database template; create table user ( id bigint auto_increment comment \u0026#39;主键\u0026#39; primary key, user_name varchar(32) not null comment \u0026#39;用户昵称\u0026#39;, password varchar(256) not null comment \u0026#39;密码\u0026#39;, user_role varchar(256) default \u0026#39;user\u0026#39; null comment \u0026#39;用户角色：user / admin\u0026#39;, avatar varchar(1024) null comment \u0026#39;头像\u0026#39;, email varchar(32) not null comment \u0026#39;邮箱\u0026#39;, phone varchar(15) null comment \u0026#39;电话\u0026#39;, create_time datetime null comment \u0026#39;创建时间\u0026#39;, update_time datetime null comment \u0026#39;更新时间\u0026#39;, is_delete tinyint(1) default 0 null comment \u0026#39;逻辑删除：1删除/0存在\u0026#39;, gender tinyint(1) null comment \u0026#39;性别\u0026#39;, status tinyint(1) default 1 not null comment \u0026#39;状态：1正常0禁用\u0026#39; ) comment \u0026#39;用户表\u0026#39;; 1 2 INSERT INTO `user` VALUES (1,\u0026#39;rose\u0026#39;,\u0026#39;e10adc3949ba59abbe56e057f20f883e\u0026#39;,\u0026#39;admin\u0026#39;,\u0026#39;admin\u0026#39;,\u0026#39;1320104286@qq.com\u0026#39;,\u0026#39;13376536162\u0026#39;,\u0026#39;2024-12-02 18:54:44\u0026#39;,\u0026#39;2024-12-02 18:54:44\u0026#39;,0,1,1); 对应的实体类：User\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Data @NoArgsConstructor @AllArgsConstructor public class User { private String userName; private String password; private String userRole; private String avatar; private String email; private String phone; private String createTime; private String updateTime; private short isDelete; private short gender; private short status; } 设计用户登录Dto\n1 2 3 4 5 6 7 8 9 10 11 12 @Data public class UserLoginDto { @NotBlank(message = \u0026#34;用户名不能为空\u0026#34;) private String username; @NotBlank(message = \u0026#34;密码不能为空\u0026#34;) private String password; @NotBlank(message = \u0026#34;验证码id不能为空\u0026#34;) private String captchaId; @NotBlank(message = \u0026#34;验证码不能为空\u0026#34;) private String captcha; } 设计用户登录Vo\n也就是登录成功后，返回给前端的信息，token以及一些非敏感信息。\n1 2 3 4 5 6 7 @Data @Builder public class UserLoginVO implements Serializable { private String token;//令牌 private String userName;//用户名 private String avatar;//头像 } 登录业务逻辑实现 代码逻辑：参数校验(使用注解方式校验)\u0026mdash;-验证码校验\u0026mdash;-账号存在检验\u0026mdash;-密码校验\u0026mdash;-用户状态判断\nservice:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 @Override public UserLoginVO login(UserLoginDto userLoginDto) { // 校验验证码 String captchaId = userLoginDto.getCaptchaId(); String userCaptcha = userLoginDto.getCaptcha(); String cacheCaptcha = stringRedisTemplate.opsForValue().get(\u0026#34;captcha:\u0026#34;+captchaId); if(cacheCaptcha == null || !cacheCaptcha.equalsIgnoreCase(userCaptcha)) { // 手动抛出异常 throw new CaptchaErrorException(ResultEnum.USER_CAPTCHA_ERROR); } // 用户存在校验 User user = new User(); user.setUserName(userLoginDto.getUsername()); // 根据用户名查询是否存在 User selectedUser = userMapper.selectByUsername(user); if(selectedUser == null) { throw new AccountNotFoundException(ResultEnum.USER_NOT_EXIST); } // 密码校验 -- 对获取的用户信息，进行校验，应该是加密后的 if(!PassUtils.verifyPassword(userLoginDto.getPassword(),selectedUser.getPassword())) { throw new PasswordErrorException(ResultEnum.USER_PASSWORD_ERROR); } log.info(\u0026#34;密码校验成功\u0026#34;); // 用户状态判断 if(selectedUser.getStatus() == 0) { log.info(\u0026#34;status 为 {}\u0026#34;,selectedUser.getStatus()); throw new AccountForbiddenException(ResultEnum.FAIL); } log.info(\u0026#34;用户状态正常\u0026#34;); // 生成token String token = JwtUtils.generateToken(Map.of(\u0026#34;userId\u0026#34;, selectedUser.getId(), \u0026#34;userRole\u0026#34;,selectedUser.getUserRole()), \u0026#34;user\u0026#34;); //构建响应对象 return UserLoginVO.builder() .userName(selectedUser.getUserName()) .avatar(selectedUser.getAvatar()) .token(token) .build(); } 注册接口 注册的时候输入：username \\password email emailcode 即可注册\n需要注意的是：为了安全性考虑，密码不能明文保存，而应该使用 加盐md5算法 进行加密储存。\n准备工作： 设计注册交互对象：\n1 2 3 4 5 6 7 8 9 10 11 @Data public class UserRegisterDto { @NotBlank(message = \u0026#34;用户不能为空\u0026#34;) private String username; @NotBlank(message = \u0026#34;密码不能为空\u0026#34;) private String password; @NotBlank(message = \u0026#34;邮箱不能为空\u0026#34;) @Pattern(regexp = \u0026#34;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\u0026#34;, message = \u0026#34;邮箱格式不正确\u0026#34;) private String email; private String captcha; } 编写密码工具类(包加密和校验)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package top.rose.template.commom.util; import cn.hutool.crypto.digest.BCrypt; /** * @ author: rose * @ date: 2024-12-04 * @ version: 1.0 * @ description: */ public class PassUtils { /** * 加密密码 * @param plainPassword 明文密码 * @return 加密后的密码*/ public static String encryptPassword(String plainPassword) { return BCrypt.hashpw(plainPassword, BCrypt.gensalt()); } /** * 验证密码 * @param plainPassword 明文密码 * @param encryptedPassword 加密后的密码 * @return 验证结果*/ public static boolean verifyPassword(String plainPassword, String encryptedPassword) { return BCrypt.checkpw(plainPassword,encryptedPassword); } } 注册业务逻辑实现： 代码逻辑：参数校验 \u0026mdash; 验证码校验 \u0026mdash; 用户邮箱存在校验 \u0026mdash;\u0026ndash; 密码加密 \u0026mdash;- 存储到数据库中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @Override public User register(@Validated UserRegisterDto userRegisterDto) { // 验证码校验 // 获取 验证码1 String registerCode = userRegisterDto.getCaptcha(); String registerEmail = userRegisterDto.getEmail(); String cacheCode = stringRedisTemplate.opsForValue().get(\u0026#34;verifycode:\u0026#34;+registerEmail); if(cacheCode == null ||!cacheCode.equals(registerCode)) { throw new CaptchaErrorException(ResultEnum.USER_CAPTCHA_ERROR); } log.info(\u0026#34;验证码校验成功\u0026#34;); // 用户或邮件存在校验,根据用户名和邮件查看是否存在 String registerUsername = userRegisterDto.getUsername(); User user = new User(); user.setUserName(registerUsername); User registerUser = userMapper.selectByUsernameOrEmail(user); if(registerUser != null) { throw new AccountRegisterFailException(ResultEnum.USER_REGISTER_FAIL); } log.info(\u0026#34;用户不存在\u0026#34;); // 密码加密 String password = userRegisterDto.getPassword(); String passwordEncrypt = PassUtils.encryptPassword(password); user.setPassword(passwordEncrypt); log.info(\u0026#34;密码加密成功\u0026#34;); // 保存用户信息 user.setUserRole(\u0026#34;user\u0026#34;); user.setCreateTime(LocalDateTime.now().toString()); user.setUpdateTime(LocalDateTime.now().toString()); user.setEmail(registerEmail); userMapper.insert(user); log.info(\u0026#34;用户注册成功\u0026#34;); return user; } 总结： 至此，就完成了登录注册功能的基础开发。\n还可以学习优化的方向是\nmapper编写的简化（用mybatis-plus)。\n登录注册方式的增加\n邮件登录，如果没有账号则进行注册后登录。 使用短信验证的方式。 ","date":"2024-12-05T17:30:29+08:00","permalink":"http://localhost:1313/2024/springboot3-%E6%95%B4%E5%90%88%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/","title":"SpringBoot3 整合登录注册"},{"content":"SpringBoot3x 脚手架开发 - 整合各种功能 总结一下自己的springboot 开发模板。依赖导入和整合各种工具。（个人学习使用）\nspringboot 3.4.0\nidea 起步依赖的选择 Developer Tools Spring Boot DevTools Lombok Web Spring Web SQL MySQL Driver MyBatis FrameWork 在idea 中创建其实也是依赖官网提供的去生成的。spring initializr\n常规项目结构 参考酒老师的template：https://gitee.com/mi9688-wine/springboot-template\nimg\rcontroller: 负责接收前端的请求、调用适当的业务逻辑、将处理的结构返回给用户类。通常控制层是不写任何业务逻辑的，它的作用主要把业务功能暴漏为接口，再者进行参数校验.\nService: 来访各种业务功能规范接口和对应的实现类的。\nmapper: 该层存放数据访问接口类，通常只需要定义出接口，具体的操作数据库的逻辑是借助ORM（对象关系映射）框架\u0026mdash;mybatis/mybatis-plus/jpa等来快捷编写或者直接生成的。\n这也就是常规的三层结构。\n**Common：**此目录用于存放全局会用到的一些静态常量类、枚举类、业务异常类、工具类、自定义注解、切面类、DTO、VO、配置类等都可以放在该目录下\nimg\rentity: Entity类通常与数据库表中的记录（Row）对应，它们之间存在一一对应的关系。\ntest: 主要用来放mapper层、service层的测试用例类.\n统一数据返回格式 放在：result.handle\n作为一种规范，其主要目的是：提高效率（复用）、提供统一的API响应格式，简化前后端交互。\n常见格式：(具体格式还是看团队，学习就用这种格式)\n1 2 3 4 5 { \u0026#34;code\u0026#34;:1, \u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;data\u0026#34; } 定义返回结果 枚举类（这里定义了基础的 0、1 和一些特殊业务错误的友好信息，后面需要进行配置）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import lombok.Getter; /** * @author mijiupro（酒师傅） */ @Getter public enum ResultEnum { /* 成功状态码 */ SUCCESS(1, \u0026#34;操作成功！\u0026#34;), /* 错误状态码 */ FAIL(0, \u0026#34;操作失败！\u0026#34;), /* 参数错误：10001-19999 */ PARAM_IS_INVALID(10001, \u0026#34;参数无效\u0026#34;), PARAM_IS_BLANK(10002, \u0026#34;参数为空\u0026#34;), PARAM_TYPE_BIND_ERROR(10003, \u0026#34;参数格式错误\u0026#34;), PARAM_NOT_COMPLETE(10004, \u0026#34;参数缺失\u0026#34;), /* 用户错误：20001-29999*/ USER_NOT_LOGGED_IN(20001, \u0026#34;用户未登录，请先登录\u0026#34;), USER_LOGIN_ERROR(20002, \u0026#34;账号不存在或密码错误\u0026#34;), USER_ACCOUNT_FORBIDDEN(20003, \u0026#34;账号已被禁用\u0026#34;), USER_NOT_EXIST(20004, \u0026#34;用户不存在\u0026#34;), USER_HAS_EXISTED(20005, \u0026#34;用户已存在\u0026#34;), /* 系统错误：40001-49999 */ FILE_MAX_SIZE_OVERFLOW(40003, \u0026#34;上传尺寸过大\u0026#34;), FILE_ACCEPT_NOT_SUPPORT(40004, \u0026#34;上传文件格式不支持\u0026#34;), /* 数据错误：50001-599999 */ RESULT_DATA_NONE(50001, \u0026#34;数据未找到\u0026#34;), DATA_IS_WRONG(50002, \u0026#34;数据有误\u0026#34;), DATA_ALREADY_EXISTED(50003, \u0026#34;数据已存在\u0026#34;), AUTH_CODE_ERROR(50004, \u0026#34;验证码错误\u0026#34;), /* 权限错误：70001-79999 */ PERMISSION_UNAUTHENTICATED(70001, \u0026#34;此操作需要登陆系统！\u0026#34;), PERMISSION_UNAUTHORIZED(70002, \u0026#34;权限不足，无权操作！\u0026#34;), PERMISSION_EXPIRE(70003, \u0026#34;登录状态过期！\u0026#34;), PERMISSION_TOKEN_EXPIRED(70004, \u0026#34;token已过期\u0026#34;), PERMISSION_LIMIT(70005, \u0026#34;访问次数受限制\u0026#34;), PERMISSION_TOKEN_INVALID(70006, \u0026#34;无效token\u0026#34;), PERMISSION_SIGNATURE_ERROR(70007, \u0026#34;签名失败\u0026#34;); // 状态码 int code; // 提示信息 String message; ResultEnum(int code, String message) { this.code = code; this.message = message; } public int code() { return code; } public String message() { return message; } public void setCode(int code) { this.code = code; } public void setMessage(String message) { this.message = message; } } 定义返回结果的封装类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import com.mijiu.commom.enumerate.ResultEnum; import lombok.Data; /** * @author mijiupro */ @Getter @Setter public class Result\u0026lt;T\u0026gt; { // 操作代码 Integer code; // 提示信息 String message; // 结果数据 T data; // 提供不同的构造方法 public Result(ResultEnum resultCode) { this.code = resultCode.code(); this.message = resultCode.message(); } public Result(ResultEnum resultCode, T data) { this.code = resultCode.code(); this.message = resultCode.message(); this.data = data; } public Result(String message) { this.message = message; } // 提供一些静态方法，以便能快速的返回对应的对象。 //成功返回封装-无数据 public static Result\u0026lt;String\u0026gt; success() { return new Result\u0026lt;String\u0026gt;(ResultEnum.SUCCESS); } //成功返回封装-带数据 public static \u0026lt;T\u0026gt; Result\u0026lt;T\u0026gt; success(T data) { return new Result\u0026lt;T\u0026gt;(ResultEnum.SUCCESS, data); } //失败返回封装-使用默认提示信息 public static Result\u0026lt;String\u0026gt; error() { return new Result\u0026lt;String\u0026gt;(ResultEnum.FAIL); } //失败返回封装-使用返回结果枚举提示信息 public static Result\u0026lt;String\u0026gt; error(ResultEnum resultCode) { return new Result\u0026lt;String\u0026gt;(resultCode); } //失败返回封装-使用自定义提示信息 public static Result\u0026lt;String\u0026gt; error(String message) { return new Result\u0026lt;String\u0026gt;(message); } } 我们的接口通常有很多，如果对每个接口都封装属于重复劳动，可以利用AOP技术拦截控制类的返回结果进行封装。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import cn.hutool.json.JSONUtil; import com.mijiu.commom.result.Result; import io.micrometer.common.lang.NonNullApi; import io.micrometer.common.lang.Nullable; import org.springframework.core.MethodParameter; import org.springframework.http.MediaType; import org.springframework.http.server.ServerHttpRequest; import org.springframework.http.server.ServerHttpResponse; import org.springframework.web.bind.annotation.RestControllerAdvice; import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice; /** * 统一结果封装增强器 * @author mijiupro */ @RestControllerAdvice(basePackages = \u0026#34;com.mijiu.controller\u0026#34;)//指定要增强的包 @NonNullApi public class ResultAdvice implements ResponseBodyAdvice\u0026lt;Object\u0026gt; { /** * 判断是否支持对返回类型的处理 * * @param returnType 方法参数的类型 * @param converterType 转换器的类型 * @return 是否支持处理 */ @Override public boolean supports(MethodParameter returnType, Class converterType) { return true; } /** * 在写入响应体之前对返回结果进行处理和封装 * * @param body 返回结果对象 * @param returnType 方法参数的类型 * @param selectedContentType 响应内容的类型 * @param selectedConverterType 转换器的类型 * @param request HTTP 请求对象 * @param response HTTP 响应对象 * @return 处理后的返回结果 */ @Override public Object beforeBodyWrite(@Nullable Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) { //当返回结果为字符串类型需要单独处理 if (body instanceof String) { // 如果返回结果是字符串类型，将其封装为成功的结果对象，并转换为 JSON 字符串 return JSONUtil.toJsonStr(Result.success(body)); } // 将返回结果封装为成功的结果对象 return Result.success(body); } } 这个如果也会对knife4j的结果进行封装，导致其knife4j文档请求异常。\n自定义异常处理器 存放到exception.handle目录中。\n自定义异常处理器以及全局处理器。用以正确捕获异常，并返回对应的调试信息。以应对不可控和一些可以预知的异常。\n通常将异常进行处理，封装一下对应错误信息返回友好信息（也就是前端一眼看得懂）。避免把异常直接给前端、用户。\n步骤一：自定义异常类 通用业务：仅仅需要返回友好的错误提示信息。不需要其他操作。 定义一个通用业务异常类，然后在业务代码中手动抛出来触发对应的返回处理。(后面需要进行配置)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * @author rose * 通用业务异常类 */ @Data public class GeneralBusinessException extends RuntimeException{ private int code=0; private String message; public GeneralBusinessException(String message) { this.message = message; } } 特殊处理业务异常：需要进行额外的逻辑处理，比如密码错误次数上限，以避免爆破攻击等等。 定义一个密码错误处理类去捕获异常，（而对应的设置错误上限逻辑就需要在全局异常处理器中实现）\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** * 密码错误异常 * @author rose */ @Data public class PasswordErrorException extends RuntimeException { // 利用枚举类来维护错误信息（也就是上面统一响应结果的枚举类） private final ResultEnum resultEnum; public PasswordErrorException(ResultEnum resultEnum) { this.resultEnum = resultEnum; } } 步骤二：创建全局异常处理器 定义的各种业务异常对应处理逻辑代码通常在全局异常处理器来写。\n需要创建一个全局异常处理器类，用于捕获和处理所有的异常。通常使用 @RestControllerAdvice注解将该类标记为全局异常处理器，并使用**@ExceptionHandler** 注解定义具体的异常处理方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /** * @author mijiupro */ @RestControllerAdvice(basePackages = \u0026#34;com.mijiu.controller\u0026#34;) @ResponseBody @Slf4j public class GlobalExceptionHandler{ // 特殊业务：密码错误异常 @ExceptionHandler(PasswordErrorException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) public Result\u0026lt;String\u0026gt; handlePasswordErrorException(PasswordErrorException ex) { //如通过redis进行密码错误计数器累加操作 //。。。。。。。。。。。。。 //日志记录等。。。。。。。。。 return Result.error(ex.getResultEnum()); } //通用业务异常处理 @ExceptionHandler(GeneralBusinessException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) public Result\u0026lt;String\u0026gt; generalBusinessExceptionHandler(GeneralBusinessException ex) { return Result.error(ex.getMessage()); } /** * 通用异常处理(用于处理不可预知的异常) */ @ExceptionHandler(Exception.class) // 捕获所有异常 public Result\u0026lt;String\u0026gt; exceptionHandler(Exception ex) { log.error(ex.getMessage()); return Result.error(ResultEnum.FAIL); } } 步骤三：手动抛出异常 对于可预见的异常：密码错误，以及通用业务异常等等都要手动抛出，就会响应对应的友好错误信息。\n对不可预见的异常，则会被通用异常处理捕获，进行统一返回”操作失败“的信息。\n常见依赖介绍 起步依赖就不再赘述了，介绍一下 常见工具包 hutoll-all\nhutoll Hutool 是一个 Java 工具包，提供了丰富的功能来简化 Java 开发中的常见任务。hutool-all 这个模块包含了 Hutool 提供的所有功能，主要包括但不限于以下几个方面：\n字符串处理：包括字符串的切割、拼接、替换、格式化等操作。 日期时间处理：提供了日期时间的格式化、解析、计算、时间间隔等功能。 加密解密：支持常见的加密算法，包括 MD5、SHA、AES、RSA 等。 文件操作：提供了文件的读写、复制、移动、压缩、解压等功能。 HTTP 客户端：支持 HTTP 请求的发送和接收，包括 GET、POST 等方法。 邮件发送：支持邮件的发送和接收，包括 SMTP 协议的使用。 图片处理：支持图片的缩放、裁剪、水印、压缩等操作。 Excel 操作：支持 Excel 文件的读写、导入导出、样式设置等功能。 PDF 操作：支持 PDF 文件的读写、合并、拆分等操作。 JSON 解析：支持 JSON 字符串的解析和生成。 常用工具类：提供了各种常用的工具类，包括数组操作、集合操作、反射工具等。\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.8.25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 面向切面的编程AOP\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 整合各种功能使用 mybatis-plus（1） 缓存中间件redis（2） swagger 接口测试（3） 参数校验（4）controller 层 dto 认证鉴权 -jwt（5） Mybatis-plus 引入依赖：（如果你遇到问题，尝试手动引入一个更高版本的mybatis依赖。）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 编写配置文件：连接信息，数据源\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver # 连接数据库的url url: jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true\u0026amp;characterEncoding=UTF-8 username: root password: 111111 #mp 基础配置 mybatis-plus: configuration: map-underscore-to-camel-case: true #打印sql日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: #id自增类型配置 id-type: ASSIGN_ID #逻辑删除字段配置 logic-delete-field: deleted logic-not-delete-value: 0 logic-delete-value: 1 #控制台mybatis-plus标记 banner: true 有个比较重要的配置：开启驼峰命名自动转化为下划线。(Mybatis-plus是自动启动的。)\ntips: 这里有个小坑就是如果数据库不是下划线格式的，就会报错。\nMybatis-plus 是mybatis 的增强，不需要手动写接口，其提供的就能满足简单业务逻辑的开发。\n内置了通用Mapper，通用Service，且自动根据实体类生成了很多个基本的sql语句\n1 2 3 @Mapper//表明这是一个Mapper，也可以在启动类上加上包扫描,添加要操作的实体类（也就对应着数据库） public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { } redis 依赖：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 配置连接信息以及连接池参数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 spring: data: redis: # Redis连接配置 host: localhost # Redis主机地址 port: 6379 # Redis端口号 password: 123456 # 访问Redis所需密码,配置密码才能进行数据操作 database: 0 # 使用的数据库编号 lettuce: #Lettuce客户端配置 pool: # 连接池配置 max-active: 8 # 最大活跃连接数 max-wait: -1 # 最大等待时间（-1表示无限等待） max-idle: 8 # 最大空闲连接数 min-idle: 0 # 最小空闲连接数 选择客户端：Lettuce（线程安全），也可以使用 Jedis。\n不需要单独导入依赖。\n配置序列化方式：(config包中)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Configuration public class RedisConfig { @Bean public RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate(RedisConnectionFactory connectionFactory) { RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate = new RedisTemplate\u0026lt;\u0026gt;(); redisTemplate.setConnectionFactory(connectionFactory); // 设置key和value的序列化方式 redisTemplate.setKeySerializer(new StringRedisSerializer()); // 设置key的序列化器为StringRedisSerializer redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer()); // 设置value的序列化器为JdkSerializationRedisSerializer redisTemplate.setHashKeySerializer(new StringRedisSerializer()); // 设置hash key的序列化器为StringRedisSerializer redisTemplate.setHashValueSerializer(new JdkSerializationRedisSerializer()); // 设置hash value的序列化器为JdkSerializationRedisSerializer redisTemplate.afterPropertiesSet(); // 初始化RedisTemplate return redisTemplate; // 返回配置好的RedisTemplate } } 使用： 采用的方式是将redisf封装成redisTemplate，交给spring容器进行管理。使用的使用注入使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 注入 redisTemplate private final StringRedisTemplate stringRedisTemplate; public UserServiceImpl(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } @Test public void testSetGet() throws Exception { System.out.println(\u0026#34;开始测试\u0026#34;); // 使用 RedisTemplate 的 opsForValue() 方法获取操作字符串的命令对象 stringRedisTemplate.opsForValue().set(\u0026#34;name\u0026#34;, \u0026#34;rose\u0026#34;, Duration.of(10, ChronoUnit.SECONDS)); // 从 Redis 中获取键为 name 的值，并将其存储在 name 变量中 String name = stringRedisTemplate.opsForValue().get(\u0026#34;name\u0026#34;); System.out.println(name); } swagger 离线接口文档， 也可以使用 Knife4j \u0026mdash; \u0026gt; swagger2 + openapi3\n这里使用Knife4J，整合了两者，swagger文档应该也是可以查看的。\n对应版本的依赖：springboot3 需要使用 4.0.0 以上的。\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.xiaoymin\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;knife4j-openapi3-jakarta-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 springdoc: swagger-ui: path: /swagger-ui.html tags-sorter: alpha operations-sorter: alpha api-docs: path: /v3/api-docs # 分组以及扫描的路径。 group-configs: - group: \u0026#39;user\u0026#39; paths-to-match: \u0026#39;/**\u0026#39; #生成文档所需的扫包路径，一般为启动类目录 packages-to-scan: top.rose #knife4j配置，不需要增强可以不配 knife4j: #是否启用增强设置 enable: true #开启生产环境屏蔽 production: false #是否启用登录认证 basic: enable: true username: admin password: 123456 setting: language: zh_cn enable-version: true enable-swagger-models: true swagger-model-name: 用户模块 使用OpenAPI3的规范注解，注解各个spring的REST接口\n@Tag注解：标记接口类别\n@Operation:标记接口操作\n访问：http://ip:port/doc.html 即可查看。\n这里要注意，不要和统一处理结果一并使用，否则会出现 knife4j 文档请求异常。\n接下来配置以下接口文档的作者等信息，在config目录下新建配置类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package top.rose.template.commom.config; /** * @ author: rose * @ date: 2024-12-02 * @ version: 1.0 * @ description: */ import io.swagger.v3.oas.models.OpenAPI; import io.swagger.v3.oas.models.info.Contact; import io.swagger.v3.oas.models.info.Info; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class Knife4jConfig { @Bean public OpenAPI springShopOpenApi() { return new OpenAPI() // 接口文档标题 .info(new Info().title(\u0026#34;rose的demo\u0026#34;) // 接口文档简介 .description(\u0026#34;这是基于Knife4j OpenApi3的测试接口文档\u0026#34;) // 接口文档版本 .version(\u0026#34;1.0版本\u0026#34;) // 开发者联系方式 .contact(new Contact().name(\u0026#34;rose\u0026#34;) .email(\u0026#34;000000000@qq.com\u0026#34;))); } } 如果你有设置拦截器，请注意把对应的路径排除。\n如果你仅仅想用swagger可以参考以下。\n导入依赖，要和你的springboot 的版本兼容\n最新的2.6.0版本，会自动加载，可以不需要手动写配置类。\n1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/org.springdoc/springdoc-openapi-starter-webmvc-ui --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springdoc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springdoc-openapi-starter-webmvc-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 如果你需要进行一些别的操作：比如配置api 的个性化描述等等，可以手动写配置类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Configuration @OpenAPIDefinition( info = @Info( title = \u0026#34;rose\u0026#39;s Api\u0026#34;, version = \u0026#34;1.0.0\u0026#34;, description = \u0026#34;This is a sample API documentation\u0026#34;, contact = @Contact( name = \u0026#34;Your Name\u0026#34;, url = \u0026#34;http://yourwebsite.com\u0026#34;, email = \u0026#34;youremail@example.com\u0026#34; ), license = @License( name = \u0026#34;Apache 2.0\u0026#34;, url = \u0026#34;http://www.apache.org/licenses/LICENSE-2.0.html\u0026#34; ) ) ) public class OpenApiConfig { // 这里可以添加其他配置 } 还有一些其他的功能：\n配置扫描接口：指定扫描的包 控制swagger是否开启，用以解决只在生成环境中使用，发布了就关闭。 配置api分组 对api添加注释信息 在yml文件中配置：\n1 2 3 4 5 6 # 要扫描的路径 springdoc: paths-to-match: /api/** # 扫描的包 springdoc: packages-to-scan: com.example.controller 如果您想要自定义扫描的路径，可以在配置类上使用 @OpenAPIDefinition 注解，并结合 @Tag 注解为特定的控制器或方法添加标签，从而更好地组织和展示 API 文档。\n@Tag注解：标记接口类别\n@Operation:标记接口操作\n参数校验 常用于dto对象，和controller 层\nspring boot注解化参数校验的初级使用\n依赖：\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 常用校验规则：\n@NotNull：用于标记字段或方法参数不能为空。非null @NotEmpty：用于标记集合、数组、字符串不能为空。非空集合、数组、字符串 @NotBlank：用于标记字符串不能为空且长度必须大于0。非null且非空字符串 @Size：用于标记集合、数组、字符串长度必须在指定范围内。 @Min：用于标记数字类型的最小值。 @Max：用于标记数字类型的最大值。 @Email：用于标记字符串必须为邮箱格式。 @NotNull用于一般的非空校验，@NotEmpty用于集合、数组、字符串的非空校验，@NotBlank则用于字符串的非空校验且长度必须大于0。\n@NotNull注解只要求不为null，无法处理空字符，空字符串在它这里是通过的。@NotBlank注解不仅要求不为null，还会要求去除前后空格后长度大于0，也就是它要求不能是空字符串。\n@Validated\n为dto对象属性添加规则，在controller开启校验@Validated注解或者@Valid注解来启用校验。在spring boot推荐用@Validated注解，因为它能够支持 Spring 提供的校验注解，并且具有更好的集成性。而@Valid 则是java标准库提供的。\n但是仅仅会返回不友好的信息\nimage-20241202164638292\r可以在在全局异常处理中进行配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 参数校验异常 @ExceptionHandler(MethodArgumentNotValidException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) public Result\u0026lt;String\u0026gt; handleValidationExceptions(Exception ex) { log.error(ex.getMessage()); // 从异常中获取字段错误信息 FieldError fieldError = ((MethodArgumentNotValidException) ex).getBindingResult().getFieldError(); if (fieldError != null) { // 获取错误提示信息 String errorMessage = fieldError.getDefaultMessage(); log.error(errorMessage); return Result.error(errorMessage); } else { // 如果没有字段错误，返回默认错误信息 log.error(ex.getMessage()); return Result.error(\u0026#34;请求参数验证失败\u0026#34;); } } image-20241202165057257\r认证鉴权 jwt jwt令牌，JWT可以被用作身份验证和授权，通过在服务器和客户端之间传递令牌来验证用户的身份并允许访问受保护的资源。\n由于JWT是基于数字签名的，所以可以确保数据的完整性和安全性。它的设计简单、易于实现，并且可以跨不同的平台和语言使用。\n它由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 如果jdk大于1.8，则还需导入下面依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 编写 jwt 工具类：\n生成JWT：用于生成JWT令牌并返回令牌字符串。\n解析JWT：用于解析JWT令牌，验证签名，并获取其中的声明信息。\n验证JWT：用于验证JWT的有效性，包括验证签名、过期时间等。\n刷新JWT：用户还在操作，马上要快过期时，延长其有效期(无感刷新)。\n其他辅助方法：例如获取JWT中的特定声明信息，验证JWT是否包含某个声明，等等。\n正常和解析是必须的，其他可以根据需求来。由于在解析 jwt时，如果出现被篡改、过期的情况就会抛出异常。也算是验证jwt。可以用来登录。\n通过类名.静态方法使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 import io.jsonwebtoken.Claims; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import java.nio.charset.StandardCharsets; import java.util.Date; import java.util.Map; /** * @author mijiupro */ public class JwtUtils { private String SECRET_KEY;// 加密密钥 private long EXPIRE_TIME; //到期时间，12小时，单位毫秒 /** * 生成token令牌 * @param claims JWT第二部分负载 payload 中存储的内容 * @param subject 主题(用户类型) * @return token */ public static String generateToken(Map\u0026lt;String,Object\u0026gt; claims, String subject) { return Jwts.builder() .setId(Claims.ID)//设置jti(JWT ID)：是JWT的唯一标识，根据业务需要，这个可以设置为一个不重复的值，主要用来作为令牌的唯一标识。 .setSubject(\u0026#34;mijiu\u0026#34;)//设置主题,一般为用户类型 .setIssuedAt(new Date())//设置签发时间 .addClaims(claims)//设置负载 .signWith(SignatureAlgorithm.HS256, SECRET_KEY)//设置签名算法 .setExpiration(new Date(System.currentTimeMillis() + EXPIRE_TIME))//设置令牌过期时间 .compact();//生成令牌 } /** * 解析token令牌 * @param token token令牌 * @return 负载 */ public static Claims parseToken(String token) { return Jwts.parser() .setSigningKey(SECRET_KEY) .parseClaimsJws(token) .getBody(); } /** * 验证token令牌 * @param token 令牌 * @return 是否有效 */ public static boolean validateToken(String token) { try { Jwts.parser() .setSigningKey(SECRET_KEY) .parseClaimsJws(token) .getBody(); return true; } catch (Exception e) { return false; } } /** * 刷新Token * @param token 旧的Token令牌 * @return 新的Token令牌 */ public static String refreshToken(String token) { try { // 解析旧的Token，获取负载信息 Claims claims = parseToken(token); // 生成新的Token，设置过期时间和签名算法等参数 return generateToken(claims, claims.getSubject()); } catch (Exception e) { throw new RuntimeException(\u0026#34;无法刷新令牌！\u0026#34;, e); } } /** * 从令牌中获取主题信息 * @param token 令牌 * @return 主题信息(用户类型) */ public static String getSubjectFromToken(String token) { try { Claims claims = parseToken(token); // 解析令牌，获取负载信息 return claims.getSubject(); // 返回主题信息 } catch (Exception e) { throw new RuntimeException(\u0026#34;无法从令牌中获取主题。\u0026#34;, e); } } } 也可以将secret 设置到配置文件中。\n基础功能完善 跨域问题 跨域问题是指在 Web 开发中，一个网页的 JavaScript 代码通过 AJAX 请求后端服务器接口时，如果请求的目标地址与当前页面的地址不在同一个域（域名、端口或协议任何一项不同），就会产生跨域问题。这种情况下，根据浏览器的安全机制（同源策略）就会会限制页面的跨域请求，以防止恶意网站对其他网站的访问和操作，保护用户信息安全。\n解决：自定义WebConfigurer 通过实现 WebMvcConfigurer 接口来自定义 WebMvc 配置，并覆盖 addCorsMappings 方法以配置全局跨域规则。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.CorsRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/**\u0026#34;) // 对所有路径生效 .allowedOrigins(\u0026#34;*\u0026#34;) //允许所有源地址,也可以时域名数组。 .allowedMethods(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;) // 允许的请求方法 .allowedHeaders(\u0026#34;*\u0026#34;); // 允许的请求头 } } 还可以通过 @CrossOrigin(origins = \u0026quot;*\u0026quot;)注解来允许跨域，以及自定义过滤器去实现。\n拦截器 ！！！！ 拦截没有对应权限的用户进行访问，也就是实现权限控制。\n拦截器流程： 用户登录后服务器会发放token等信息（jwt）返回给前端，前端进行保存（header中），再携带着该token 访问服务器，首先会被拦截，只有校验通过后，才能正确的返回对应的资源，否则会抛出异常。\ntips: 每次登录都创建token 用户访问期间token 不能失效，需要及时刷新 \u0026mdash;\u0026ndash; 》 通过每次访问接口，就刷新token来解决。 token 被正确解析后，根据解析的内容，查询对应的数据。 实现步骤：（核心） 定义拦截器 \u0026mdash;- 创建拦截器配置类 \u0026mdash;- 配置拦截器顺序 \u0026mdash;- 配置拦截器排除项。\n1 定义拦截器 为了解决用户访问期间token 不会失效，为其设置一个专门刷新token的拦截器 RefreshTokenInterceptor。\n需要注意的是：不是拦截所有的访问都需要token，比如一些没有登录浏览的页面等等，如果没有token就直接放行，有token就刷新。最后请求处理完一定要清理一下本地线程，不然用户多的时候内存占用会很大。\n需要实现 Spring 框架提供的 HandlerInterceptor 接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @Component @Slf4j public class RefreshTokenInterceptor implements HandlerInterceptor { // redis 和 jwt 的使用 public final StringRedisTemplate stringRedisTemplate; public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 1 判断是否有token,没有token 就放行 String authorizationHeader = request.getHeader(\u0026#34;authorization\u0026#34;); if(StringUtils.isBlank(authorizationHeader)) { return true; } // 2 解析token --- 这里如果解析出错怎么办？？？？ Claims claims = JwtUtils.parseToken(authorizationHeader); if(Objects.isNull(claims)) return true; // 3 获取用户信息 Integer userId = claims.get(\u0026#34;userId\u0026#34;,Integer.class); // 从redis中获取信息。 String userInfoJson = stringRedisTemplate.opsForValue().get(\u0026#34;login:user:\u0026#34;+userId); if(StringUtils.isBlank(userInfoJson)) return true; // 4 刷新token String refreshToken = JwtUtils.refreshToken(authorizationHeader); response.setHeader(\u0026#34;Access-Control-Expose-Headers\u0026#34;,\u0026#34;Authorization\u0026#34;); response.setHeader(\u0026#34;Authorization\u0026#34;,refreshToken); stringRedisTemplate.expire(\u0026#34;login:user:\u0026#34;+userId,30, TimeUnit.MINUTES); // 5 将用户信息存储到本地线程 User user = JSONUtil.toBean(userInfoJson, User.class); // 这个再具体看模板 UserHolder UserHolder.setInfoByToken(user); return true; } // 执行后清理一下本地线程 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { UserHolder.clear(); } } 除此还需要一个身份认证的拦截器，用以身份认证。LoginInterceptor\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Component @Slf4j public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 在经过该拦截器前会有token判断是否存在，因此只需要判断本地线程中是否有用户信息 log.info(\u0026#34;进入登录拦截器\u0026#34;); User user = UserHolder.getInfoByToken(); if(Objects.isNull(user)){ log.info(\u0026#34;过期异常！\u0026#34;); throw new TokenOverdueException(ResultEnum.PERMISSION_EXPIRE); } log.info(\u0026#34;放行\u0026#34;); return true; } } 创建拦截器配置类 创建一个配置类，用于配置拦截器链。在该配置类中，通过实现 WebMvcConfigurer 接口来添加拦截器，具体包括 addInterceptors 方法。（和上文的解决跨域问题的配置类一起）\n配置拦截器顺序：通过 .order(0) 进行配置拦截器的顺序\n配置拦截器排除项 .excludePathPatterns()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Configuration public class WebConfig implements WebMvcConfigurer { // 拦截器配置 private final RefreshTokenInterceptor refreshTokenInterceptor; private final LoginInterceptor loginInterceptor; public WebConfig(RefreshTokenInterceptor refreshTokenInterceptor, LoginInterceptor loginInterceptor) { this.refreshTokenInterceptor = refreshTokenInterceptor; this.loginInterceptor = loginInterceptor; } public void addInterceptors(InterceptorRegistry registry) { // 对所有路劲进行拦截，顺序为 0 registry.addInterceptor(refreshTokenInterceptor) .addPathPatterns(\u0026#34;/**\u0026#34;).order(0); // 登录拦截器，拦截除登录注册以及 swagger 的路径，以及一些静态资源 registry.addInterceptor(loginInterceptor) .excludePathPatterns(\u0026#34;/\u0026#34;,\u0026#34;*/login\u0026#34;) .order(1); } // 跨域问题解决 @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/**\u0026#34;) // 对所有路径生效 .allowedOrigins(\u0026#34;*\u0026#34;) //允许所有源地址 // .allowedOrigins(\u0026#34;https://mijiupro.com\u0026#34;,\u0026#34;https://mijiu.com \u0026#34;) // 允许的源地址（数组） .allowedMethods(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;) // 允许的请求方法 .allowedHeaders(\u0026#34;*\u0026#34;); // 允许的请求头 } } 知道其流程：\n登录后将用户信息存储到redis中，设置有效期30分钟。\n然后 将userid 放到jwt中添加到前端中 authorization字段中。\n","date":"2024-12-05T17:01:27+08:00","permalink":"http://localhost:1313/2024/springboot%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/","title":"Springboot脚手架开发"},{"content":"记录Knife4j与自定义统一结果的冲突 在使用 knife4j-openapi3-jakarta-spring-boot-starter的时候，明明版本使用正确，但是访问 doc.html 时总是出现 文档请求异常。\n问题解决思考： 使用 最近比较火的 ai 编程助手进行分析，给出的建议是：查看配置、依赖等等（可能是我没有给出更详细的日志信息）。\n于是我重开了一个项目，进行测试，发现可以成功的运行。证明spring boot版本和Knife4j 版本并没有问题。\n排除了版本适配问题，便把矛头指向 其他依赖。\n因此搜索： knife4j 与什么依赖会生成冲突？\n找到文章：记录解决knife4j与自定义统一返回冲突问题\n给出原因是：主要原因是knife4j的返回值，被自定义的统一返回封装后，页面无法解析。\n但是为什么呢？https://doc.xiaominfo.com/docs/faq/knife4j-exception\n在knife4j 官网中发现swagger 接口有固定的格式，如果有对接口进行统一的封装，会导致接口处理异常。需要手动的去除掉对swagger分组的封装。\n而我的项目中有全局异常处理接口，返回友好信息。只需要手动去除即可。\n//@RestControllerAdvice(basePackages = \u0026quot;top.rose.template.controller\u0026quot;)\n","date":"2024-12-02T16:09:40+08:00","permalink":"http://localhost:1313/2024/knife4j%E4%B8%8E%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%9F%E4%B8%80%E7%BB%93%E6%9E%9C%E7%9A%84%E5%86%B2%E7%AA%81/","title":"Knife4j与封装自定义统一结果的冲突"},{"content":"follow 新一代信息浏览器 最近发现了一个超级神器，follow ！ 一款有过滤自己的输入，对自己的信息输入掌握主动权。\n而我由于一直苦恼于想通过B站进行信息摄入，但是又常常会被一些无关紧要的视频收割了注意力，尽管那些视频有些“低脂”，但凡问自己一句“你要看这个视频吗？” 答案都会是否。但是就是控制不住自己，也许是我意志力薄弱，但是follow 无疑是有利于改善这个问题的。\n所以follow是什么？\n简单的来说：就是一款基于rss的信息聚合阅读器。\nrss: 聚合自己的信息源，可以更多的优质摄入。\n但由于 rss 会减少网站的收益，因此网站不再主动提供 rss。而 rsshub 就很好的解决了这个问题，通过爬虫帮我们将站点转化为rss,以便我们进行信息的聚合。https://rsshub.netlify.app/zh/usage\n而 follow 则是基于RSSHUB ，使用极其方便，只需要给链接 进行搜索即可。也可以上 rsshub 去查看rsshub 路由如何写，手动添加。\nimage-20241201233906637\r由于 还在公测阶段，follow 对订阅数量有所限制，因此我在小黄鱼买了邀请码，开放了更多的订阅限制。\n还获得了一些follow的使用教程、热门的订阅，一键导入。\n至于如何使用我就不赘述了，给出文章进行参考。\n资源分享：\n我用夸克网盘分享了「【follow的详细使用教程和优质订阅源合集】」，点击链接即可保存。 链接：https://pan.quark.cn/s/e6a2ad8e31ce\nimage-20241201235726662\rtop-rss-list github地址: https://github.com/weekend-project-space/top-rss-list\nfollow 基础使用教程： https://lillianwho.com/posts/follow%E6%94%BB%E7%95%A5/\n","date":"2024-12-02T00:06:06+08:00","permalink":"http://localhost:1313/2024/follow-%E5%BC%80%E6%BA%90%E7%9A%84rss%E9%98%85%E8%AF%BB%E5%99%A8/","title":"Follow-开源的RSS阅读器"},{"content":"SpirngBoot3.4与MyBatisplus 3.5.5 不兼容问题 在学习使用mybatis-plus时，出现了 项目搭建不起来。\n报错信息为：\n1 Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanDefinitionStoreException: Invalid bean definition with name \u0026#39;userMapper\u0026#39; defined in file [C:\\javaweb\\Template\\target\\classes\\top\\rose\\template\\mapper\\UserMapper.class]: Invalid value type for attribute \u0026#39;factoryBeanObjectType\u0026#39;: java.lang.String Invalid bean definition with name 'userMapper' defined in file\n可以知道时bean管理出现问题了，但是我仅仅是最简单的 测试插入。 @Mapper @MapperScan 都尝试了，均没有用。\n后了解到：Springboot 的版本和 Mybatis plus 中自带 mybatis 版本不兼容。\n因此手动剔除自带版本，手动添加最新版本即可解决。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; ","date":"2024-11-29T19:31:08+08:00","permalink":"http://localhost:1313/2024/spirngboot3.4%E4%B8%8Emybatisplus-3.5.5-%E4%B8%8D%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/","title":"SpirngBoot3.4与MyBatisplus 3.5.5 不兼容问题"},{"content":"SpringBoot3 实现登录注册功能-1 仅仅是一枚新手实现功能的记录。仅是一个参考，还有很多不足，后续再完善。\n该文主要是学习了简单的登录注册功能、邮箱验证、拦截器的设置。\n后续还得学习上验证码的生成以及时效性、设置前端header、springBoot security(本来是有用到的，但是频繁出现小问题，决定先不用后续再学习。)还有邮箱验证登录等等。\n也会有一些不同的注册思路需要学习。\n流程、接口 简单提一嘴：dto\\do ： do也就是实体类，和数据库一一对应，dto是层与层之间交互的实体类，用来封装前端传来的数据。\n由于没有前端，简单了解一下流程：\n注册：\n用户输入用户、密码、邮件进行注册，会发送验证码进行注册，验证码验证成功后将数据存储到数据库中。\nimage-20241120211610319\r数据库表: userid 、username 、password、 email\n发送邮件： 要实现发送邮箱验证，使用 spring mail\n添加依赖：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-mail\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 用qq邮箱，配置邮箱客户端\nimage-20241120232744235\r开启服务后就会有个授权码，要配置到yml文件中。\n1 2 3 4 5 6 7 8 spring: #邮件服务配置 mail: host: smtp.qq.com #邮件服务器地址 protocol: smtp #协议 username: #发送邮件的邮箱也就是你开通服务的邮箱 password: #开通服务后得到的授权码 default-encoding: utf-8 #邮件内容的编码 接着就可以使用了，简单示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * 点击发送验证码给对应的邮箱 * @param email 邮箱 */ @Override public void sendEmail(String email) { //生成对应的验证码取uuid的0-6位 String code = UUID.randomUUID().toString().substring(0,6); // 设置邮箱要发送的信息： String subject = \u0026#34;健康管理系统的验证码\u0026#34;; String message = \u0026#34;验证码为：\u0026#34;+code; // 创建一个mailMessage对象 SimpleMailMessage mailMessage = new SimpleMailMessage(); // 设置发送的邮箱 mailMessage.setFrom(\u0026#34;1320104286@qq.com\u0026#34;); mailMessage.setTo(email); // 设置主题和内容 mailMessage.setSubject(subject); mailMessage.setText(message); // 发送邮件 mailSender.send(mailMessage); } 注册基础功能实现 流程：\nimage-20241121001127648\r邮箱验证 先完成邮件的验证（暂时是临时存储，以及随机的uuid进行注册）\nController层\n1 2 3 4 5 6 7 8 @PostMapping(\u0026#34;/verify\u0026#34;) public Result add(@RequestBody EmailDto emailDto) { log.info(\u0026#34;给邮箱{}发送验证码\u0026#34;,emailDto.getEmail()); userService.sendEmail(emailDto.getEmail()); return Result.success(\u0026#34;邮件已发送\u0026#34;); } } Service 层\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 临时存储邮箱和对应的验证码 private Map\u0026lt;String,String\u0026gt; verifyCodes = new HashMap\u0026lt;\u0026gt;(); @Override public void sendEmail(String email) { //生成对应的验证码取uuid的0-6位 String code = UUID.randomUUID().toString().substring(0,6); verifyCodes.put(email,code); // 到时候这部分修改一下 String subject = \u0026#34;健康管理系统的验证码\u0026#34;; String message = \u0026#34;验证码为：\u0026#34;+code; SimpleMailMessage mailMessage = new SimpleMailMessage(); mailMessage.setFrom(\u0026#34;1320104286@qq.com\u0026#34;); mailMessage.setTo(email); mailMessage.setSubject(subject); mailMessage.setText(message); mailSender.send(mailMessage); } 实现注册 实现注册：需要对密码进行处理，以及对数据库进行查询是否存在。\nController\n1 2 3 4 5 6 7 8 9 @PostMapping(\u0026#34;/register\u0026#34;) public Result add(@RequestBody RegisterDto registerDto) { Integer Id = userService.register(registerDto); if( Id== null) { return Result.error(\u0026#34;用户名或邮箱已经存在！注册失败！\u0026#34;); } return Result.success(\u0026#34;用户创建成功，id为:\u0026#34;+Id); } service\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * 对包含 验证码的请求进行处理。 * @param registerDto web端传进来的参数。 * @return 返回 用户的id,感觉有点多余 */ @Transactional(rollbackFor = Exception.class) @Override public Integer register(RegisterDto registerDto) { // 如果已经存在用户了，则无法注册 if(userMapper.getByUserNameOrEmail(registerDto.getUsername()) != null) { return null; }else{ // 没有找到用户 log.info(\u0026#34;用户不存在，可以注册！\u0026#34;); //这里去获取user里的临时存储的code String code = verifyCodes.get(registerDto.getEmail()); // 验证code是否正确且验证对应的email(上面获取code的过程就判断了) if(code != null \u0026amp;\u0026amp; code.equals(registerDto.getCode())) { // 这里要处理user的password ! String secretPass = PassUtils.encryptPassword(registerDto.getPassword()); registerDto.setPassword(secretPass); userMapper.add(registerDto); return userMapper.getIdByUserName(registerDto); } // 注册失败 return null; } } 这里的密码加密采用的Bcrypt 算法，会随机生成盐对密码进行加密，且不可逆，是最主流的密码加密算法。\n密码加密： 需要导入依赖：\n1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/org.mindrot/jbcrypt --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mindrot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jbcrypt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 编写PassUtils类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class PassUtils { /** * 加密密码 * @param plainPassword 明文密码 * @return 加密后的密码*/ public static String encryptPassword(String plainPassword) { return BCrypt.hashpw(plainPassword,BCrypt.gensalt()); } /** * 验证密码 * @param plainPassword 明文密码 * @param encryptedPassword 加密后的密码 * @return 验证结果*/ public static boolean verifyPassword(String plainPassword, String encryptedPassword) { return BCrypt.checkpw(plainPassword,encryptedPassword); } } 注册测试： 根据流程，需要接收前端的Email，封装到EmailDto类中，会发送验证码。\nimage-20241121003214150\r对应的邮箱接收到了验证码，也就证明注册成功。\nimage-20241121003530208\r查看数据库：证明注册成功。\nimage-20241121003621821\r这里说明一下：BCrypt 加密后长度固定为60个字符。\n登录 对应的登录流程也需要对密码进行校验，这里要学习的关键是jwt身份认证\nController （这里应该为前端访问的用户设置header token = jwt,先将jwt返回给前端，由前端setheaders ）\n1 2 3 4 5 6 7 8 9 10 11 12 @PostMapping(\u0026#34;/login\u0026#34;) public Result login(@RequestBody LoginDto loginDto) { log.info(\u0026#34;登录的账号：{}，{}\u0026#34;,loginDto.getUsername(),loginDto.getPassword()); String jwt = userService.login(loginDto); if(jwt != null) { return Result.success(jwt); } return Result.error(\u0026#34;登录失败\u0026#34;); } service (关键在于密码的验证)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * 登录接口 * @param loginDto 控制层传输过来的信息 * @return 返回jwt */ @Override public String login(LoginDto loginDto) { /* 验证账号和密码，并生成jwt进行返回 */ // 这里应该换成dto,后面再修改,还有VO // 密码加密再进行查询 UserDo userDo = userMapper.checkLogin(loginDto); log.info(\u0026#34;要登录的用户:{}\u0026#34;,userDo); if(PassUtils.verifyPassword(loginDto.getPassword(),userDo.getPassword())) { log.info(\u0026#34;登录成功设置返回jwt\u0026#34;); // 并设置为普通用户 return JwtUtils.generateJwt(loginDto.getUsername(),\u0026#34;user\u0026#34;); } log.info(\u0026#34;账号或密码错误!\u0026#34;); return null; } Mapper层很简单：就是根据用户用户名查询对应的数据userDo.\njwt 简单来说 jwt令牌 就是一种身份认证，你只有带有对应的令牌才能有对应的权限。（结合拦截器使用，进行登录验证）\n关于jwt的相关知识，可以看https://blog.csdn.net/shenyunmomie/article/details/139805325\n和https://blog.csdn.net/weixin_43443913/article/details/140479283 进行了解，这里就不赘述了。\n快速入门：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!--jwt相关依赖 jdk1.8 以前就只需要导第一个--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.12.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt-impl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.12.6\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 编写jwtUtils\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @Data @Component @ConfigurationProperties(prefix = \u0026#34;jwt\u0026#34;) // 从配置文件中获取相关的属性值 public class JwtUtils { // 签名算法需要的密钥 private static long expiration = 12*60*60*1000; //有效期是12小时 private static SecretKey key = Jwts.SIG.HS256.key().build(); //密钥是随机生成的。 /** * 生成token * @param name 用户名 * @param subject 用户类型 * @return 返回token */ public static String generateJwt(String name, String subject) { String jwt = Jwts.builder() .subject(subject) // 设置主题一般是用户类型 .issuedAt(new Date()) .claim(\u0026#34;name\u0026#34;,name) .signWith(key) .expiration(new Date(System.currentTimeMillis()+expiration)) // 设置有效期 .compact(); return jwt; } /** * * @param jws jws字符串 * @return 返回一个对象 */ public static Object parseJwt(String jws) { return Jwts.parser() .verifyWith(key) .build() .parseSignedClaims(jws); } } 然后再登录后根据其用户名生成一个jwt.\n登录测试： image-20241121005845573\r拦截器 就是当没有带合法jwt的用户都会被拦截，只能访问登录注册页面。\n编写登录拦截器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Slf4j @Component public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest req, HttpServletResponse resp, Object handler) throws Exception { Gson gson = new Gson(); String jwt = req.getHeader(\u0026#34;token\u0026#34;); // 1 判断是否存在 jwt 不存在则返回错误结果 if(StringUtil.isNullOrEmpty(jwt)) { log.info(\u0026#34;token为空，返回未登录信息！\u0026#34;); Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); // 手动转成json对象 -- 阿里巴巴 的fastJson String notLogin = gson.toJson(error); resp.getWriter().write(notLogin); return false; } // 5 判断jwt是否被篡改或者失效 try{ JwtUtils.parseJwt(jwt); }catch (Exception e) { log.info(\u0026#34;jwt被篡改或失效，返回登录信息\u0026#34;); Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); // 手动转成json对象 -- 阿里巴巴 的fastJson String notLogin = gson.toJson(error); resp.getWriter().write(notLogin); return false; } // 6 放行 log.info(\u0026#34;令牌合法！放行！\u0026#34;); return true; } } 配置拦截器\n1 2 3 4 5 6 7 8 9 10 @Configuration public class LoginConfig implements WebMvcConfigurer { @Autowired private LoginInterceptor loginInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(loginInterceptor).addPathPatterns(\u0026#34;/**\u0026#34;).excludePathPatterns(\u0026#34;/login\u0026#34;,\u0026#34;/register\u0026#34;,\u0026#34;/verify\u0026#34;,\u0026#34;/swagger-ui/index.html\u0026#34;); } } 全局异常处理器 由于开发过程中多多少少会出现一些异常。因此可以设置一个全局异常管理器去管理没有被处理的异常，保证程序可以正常使用。\n很简单就不赘述了。\n1 2 3 4 5 6 7 8 9 10 11 12 @Slf4j @RestControllerAdvice public class GlobalException { // 处理所有异常 @ExceptionHandler(Exception.class) public Result ex(Exception e) { e.printStackTrace(); return Result.error(\u0026#34;对不起,操作失败,请联系管理员!\u0026#34;); } } 总结： 到此我们就完成了一个相对完整且基础的登录注册流程，使用了jwt\\拦截器、异常处理、BCrypt进行密码加密存储以及邮箱验证。\n","date":"2024-11-20T21:09:40+08:00","permalink":"http://localhost:1313/2024/springboot%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E5%92%8C%E7%99%BB%E5%BD%95/","title":"SpringBoot实现注册和登录"},{"content":" 这两天学习了GUI编程后，实现的小项目，还有记事本，记事本难点较少，画图板自己解决不了，遂记录一下\n画画板项目 要求：\n开发一款简单的画图软件, 包含如下功能：\n画笔 矩形/椭圆绘制 清屏 橡皮擦 直线/带箭头的直线 修改画笔颜色、背景颜色 代码框架都是有套路的，找一个自己用得顺得模板。\n基本框架 要先理清要完成的功能！\n组件的实现 组件的事件绑定 组件事件的完成 组件的实现比较容易：只有8个按钮和1个画板\n组件事件的完成：要理清每一种功能的本质\n组件的事件绑定：这里的难点在于按下按钮要执行对应的事件，也就是一个事件要和 “按钮”、“画布“进行绑定\n这里学到的事件和两个按钮绑定的方法：利用一个eventManager()方法：\n在按钮组件里，加上name属性 左键按钮事件，绑定eventManager()方法 eventManager中获取点击组件的name属性，根据name属性执行对应的功能方法 组件事件的完成也是相对困难的(之前并未了解到)\n需要先了解过程：\n点击\u0026mdash;绘画\u0026mdash;释放 ，一次绘画，包含着三个过程\n点击\u0026mdash;》进入eventManager方法\u0026mdash;\u0026gt;调用对应功能的方法（执行无数次）\u0026mdash;\u0026gt;释放，将参数清零\n注意点：\n在事件函数前都要加上一个 begin方法，将flag设置为1，stop方法（绑定左键释放）的时候，再修改成0。\n也应该为每次设置一个 lastDraw参数。要理解，绘画过程其实是无数次事件执行，比如矩形，就是起始点和鼠标点形成矩形，但是在绘画是，我们不希望每时刻的矩形都被出现，只需要最后一个矩形，因此需要设置参数，每次开始前beigin方法将其删除。（canvas返回的是id）没有释放的效果如下：\nimage-20240902093708969\r具体实现 相关参数： 1 2 3 4 5 6 7 8 9 10 11 12 def __init__(self,master=None,bgcolor=\u0026#34;#000000\u0026#34;): super().__init__() self.master = master self.bgcolor = bgcolor #背景色，也是橡皮檫的色 self.canvas = None # 画布 self.fgcolor = \u0026#34;#ff0000\u0026#34; # 线条的颜色 self.x = 0 #这个用于保存刚刚点击时的坐标 self.y = 0 self.lastDraw = 0 # 用以记录 canvas返回的id,以便管理绘画的周期 self.startDrawFlag = False # 绘画开关 self.pack() self.createWedigt() 组件的创建： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def createWedigt(self): # 1. 创建画布，背景为黑色 self.canvas = Canvas(root,background=self.bgcolor,width=800,height=400) self.canvas.pack() # 2. 创建按钮 btn01 = Button(self, text=\u0026#34;开始\u0026#34;,name=\u0026#34;start\u0026#34;) btn01.pack(side=\u0026#34;left\u0026#34;,padx=5) btn02 = Button(self, text=\u0026#34;画笔\u0026#34;, name=\u0026#34;pen\u0026#34;) btn02.pack(side=\u0026#34;left\u0026#34;,padx=5) btn03 = Button(self, text=\u0026#34;画矩形\u0026#34;,name=\u0026#34;rect\u0026#34;) btn03.pack(side=\u0026#34;left\u0026#34;,padx=5) btn04 = Button(self, text=\u0026#34;清屏\u0026#34;,name=\u0026#34;clear\u0026#34; ) btn04.pack(side=\u0026#34;left\u0026#34;,padx=5) btn05 = Button(self, text=\u0026#34;橡皮檫\u0026#34;, name=\u0026#34;erasor\u0026#34;) btn05.pack(side=\u0026#34;left\u0026#34;,padx=5) btn06 = Button(self, text=\u0026#34;直线\u0026#34;, name=\u0026#34;line\u0026#34;) btn06.pack(side=\u0026#34;left\u0026#34;,padx=5) btn07 = Button(self, text=\u0026#34;直线（箭头）\u0026#34;, name=\u0026#34;lineArrow\u0026#34;) btn07.pack(side=\u0026#34;left\u0026#34;,padx=5) btn08 = Button(self, text=\u0026#34;颜色\u0026#34;,name=\u0026#34;color\u0026#34;) btn08.pack(side=\u0026#34;left\u0026#34;,padx=5) # 3 进行事件绑定！！ 注意看 # bind_class 绑定所有Button按钮 btn02.bind_class(\u0026#34;Button\u0026#34;,\u0026#34;\u0026lt;Button-1\u0026gt;\u0026#34;,self.eventManager) # 绑定释放按钮 self.canvas.bind(\u0026#34;\u0026lt;ButtonRelease-1\u0026gt;\u0026#34;,self.stopDraw) eventManager的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def eventManager(self,event): name = event.widget.winfo_name() print(name) if name == \u0026#34;line\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;,self.line) elif name == \u0026#34;lineArrow\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.linewithhead) elif name == \u0026#34;rect\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.rect) elif name == \u0026#34;pen\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.pen) elif name == \u0026#34;erasor\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.Erasor) elif name == \u0026#34;clear\u0026#34;: # clear 就删除所有 self.canvas.delete(\u0026#34;all\u0026#34;) elif name == \u0026#34;color\u0026#34;: # 调起颜色选择器，设置到fgcolor属性 c = askcolor(color=\u0026#34;black\u0026#34;, title=\u0026#34;选择画笔颜色\u0026#34;) self.fgcolor = c[1] elif name == \u0026#34;start\u0026#34;: messagebox.showinfo(\u0026#34;你好！\u0026#34;,\u0026#34;开始画画\u0026#34;) 事件的实现： 开始结束：\n1 2 3 4 5 6 7 8 9 10 11 12 13 def stopDraw(self,event): print(\u0026#34;绘画结束\u0026#34;) self.startDrawFlag = False # 每次结束后重置，避免刚刚画的被下一个操作的begin()删除 self.lastDraw = 0 def begin(self,event): # 删除绘画过程中不必要的图像 self.canvas.delete(self.lastDraw) if not self.startDrawFlag: self.startDrawFlag = True self.x = event.x #保存当前位置的坐标 self.y = event.y 不同功能实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def pen(self,event): self.begin(event) self.canvas.create_line(self.x,self.y,event.x,event.y,fill=self.fgcolor) self.x = event.x self.y = event.y def rect(self,event): self.begin(event) self.lastDraw = self.canvas.create_rectangle(self.x,self.y,event.x,event.y,outline=self.fgcolor) def Erasor(self,event): \u0026#34;\u0026#34;\u0026#34;其实就是线条白色\u0026#34;\u0026#34;\u0026#34; self.begin(event) self.canvas.create_rectangle(event.x-4,event.y-4,event.x,event.y,fill=self.bgcolor) self.x = event.x self.y = event.y def line(self,event): self.begin(event) # 以记录的xy 到当前鼠标的xy self.lastDraw = self.canvas.create_line(self.x,self.y,event.x,event.y,fill=self.fgcolor) def linewithhead(self,event): self.begin(event) self.lastDraw = self.canvas.create_line(self.x,self.y,event.x,event.y,arrow=LAST,fill= self.fgcolor) 将python文件生成exe文件 本质：把python解释器和py文件捆绑，生成exe文件\n使用pyinstaller模板\n1 pyinstaller -F xxx.py 最终代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 \u0026#34;\u0026#34;\u0026#34; 开发一款简单的画图软件, 包含如下功能： 1. 画笔 2. 矩形/椭圆绘制 3. 清屏 4. 橡皮擦 5. 直线/带箭头的直线 6. 修改画笔颜色、背景颜色 \u0026#34;\u0026#34;\u0026#34; # 尽力完成，结构更加重要 # 单行文本框 from tkinter import * from tkinter import messagebox from tkinter.colorchooser import * class Application(Frame): def __init__(self,master=None,bgcolor=\u0026#34;#000000\u0026#34;): super().__init__() self.master = master self.bgcolor = bgcolor self.canvas = None self.fgcolor = \u0026#34;#ff0000\u0026#34; self.x = 0 self.y = 0 self.lastDraw = 0 self.startDrawFlag = False self.pack() self.createWedigt() def createWedigt(self): # 1. 创建画布，背景为黑色, self.canvas = Canvas(root,background=self.bgcolor,width=800,height=400) self.canvas.pack() # 2. 创建按钮 btn01 = Button(self, text=\u0026#34;开始\u0026#34;,name=\u0026#34;start\u0026#34;) btn01.pack(side=\u0026#34;left\u0026#34;,padx=5) btn02 = Button(self, text=\u0026#34;画笔\u0026#34;, name=\u0026#34;pen\u0026#34;) btn02.pack(side=\u0026#34;left\u0026#34;,padx=5) btn03 = Button(self, text=\u0026#34;画矩形\u0026#34;,name=\u0026#34;rect\u0026#34;) btn03.pack(side=\u0026#34;left\u0026#34;,padx=5) btn04 = Button(self, text=\u0026#34;清屏\u0026#34;,name=\u0026#34;clear\u0026#34; ) btn04.pack(side=\u0026#34;left\u0026#34;,padx=5) btn05 = Button(self, text=\u0026#34;橡皮檫\u0026#34;, name=\u0026#34;erasor\u0026#34;) btn05.pack(side=\u0026#34;left\u0026#34;,padx=5) btn06 = Button(self, text=\u0026#34;直线\u0026#34;, name=\u0026#34;line\u0026#34;) btn06.pack(side=\u0026#34;left\u0026#34;,padx=5) btn07 = Button(self, text=\u0026#34;直线（箭头）\u0026#34;, name=\u0026#34;lineArrow\u0026#34;) btn07.pack(side=\u0026#34;left\u0026#34;,padx=5) btn08 = Button(self, text=\u0026#34;颜色\u0026#34;,name=\u0026#34;color\u0026#34;) btn08.pack(side=\u0026#34;left\u0026#34;,padx=5) # 3 进行事件绑定！！ 注意看 btn02.bind_class(\u0026#34;Button\u0026#34;,\u0026#34;\u0026lt;Button-1\u0026gt;\u0026#34;,self.eventManager) self.canvas.bind(\u0026#34;\u0026lt;ButtonRelease-1\u0026gt;\u0026#34;,self.stopDraw) def eventManager(self,event): name = event.widget.winfo_name() print(name) if name == \u0026#34;line\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;,self.line) elif name == \u0026#34;lineArrow\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.linewithhead) elif name == \u0026#34;rect\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.rect) elif name == \u0026#34;pen\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.pen) elif name == \u0026#34;erasor\u0026#34;: self.canvas.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.Erasor) elif name == \u0026#34;clear\u0026#34;: self.canvas.delete(\u0026#34;all\u0026#34;) elif name == \u0026#34;color\u0026#34;: c = askcolor(color=\u0026#34;black\u0026#34;, title=\u0026#34;选择画笔颜色\u0026#34;) self.fgcolor = c[1] elif name == \u0026#34;start\u0026#34;: messagebox.showinfo(\u0026#34;你好！\u0026#34;,\u0026#34;开始画画\u0026#34;) # 3 完成对应的操作 def stopDraw(self,event): print(\u0026#34;绘画结束\u0026#34;) self.startDrawFlag = False self.lastDraw = 0 def begin(self,event): self.canvas.delete(self.lastDraw) if not self.startDrawFlag: self.startDrawFlag = True self.x = event.x self.y = event.y def pen(self,event): self.begin(event) self.canvas.create_line(self.x,self.y,event.x,event.y,fill=self.fgcolor) self.x = event.x self.y = event.y def rect(self,event): self.begin(event) self.lastDraw = self.canvas.create_rectangle(self.x,self.y,event.x,event.y,outline=self.fgcolor) def Erasor(self,event): \u0026#34;\u0026#34;\u0026#34;其实就是线条白色\u0026#34;\u0026#34;\u0026#34; self.begin(event) self.canvas.create_rectangle(event.x-4,event.y-4,event.x,event.y,fill=self.bgcolor) self.x = event.x self.y = event.y def line(self,event): self.begin(event) # 以记录的xy 到当前鼠标的xy self.lastDraw = self.canvas.create_line(self.x,self.y,event.x,event.y,fill=self.fgcolor) def linewithhead(self,event): self.begin(event) self.lastDraw = self.canvas.create_line(self.x,self.y,event.x,event.y,arrow=LAST,fill= self.fgcolor) if __name__ == \u0026#39;__main__\u0026#39;: root = Tk() root.geometry(\u0026#34;800x500+100+200\u0026#34;) app = Application(root) root.mainloop() ","date":"2024-09-02T08:59:25+08:00","permalink":"http://localhost:1313/2024/imgs/","title":"GUI编程-画画坂"},{"content":"python网络编程 这也仅仅是python网络编程的入门，没有涉及到文件传输，也就是最基础的框架。UCP和TCP传输信息，并使用多线程进行双向通信。\npython也是socket套接字的编程。\n基础知识点 socket 套接字 socket 可以相当于是 “一次网络连接”\nsocket.socket([family[, type[, proto]]])\nfamily : 套接字家族可以使 AF_UNIX 或者 AF_INET ；\nAF 表示ADDRESS FAMILY 地址族 AF_INET（又称 PF_INET）是 IPv4 网络协议的套接字类型；而 AF_UNIX 则是 Unix 系统本地通信。\ntype : 套接字类型可以根据是面向连接的还是非连接分为 SOCK_STREAM 或 SOCK_DGRAM ； protocol : 一般不填，默认为0。\nsocket 基础的内置函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 s.bind() # 绑定地址到套接字上 s.listen() # 开启tcp监听 s.accept() # 被动接受客户端连接（阻塞） s.connect() # 客户端连接服务端 # 接受和发送信息 # 面向连接的，只有一个参数或返回值 s.send() s.recv() # 面对连接的，还需要多一个元组，表明目的IP地址和端口 s.sendto() s.recvfrom() # 这些仅是基础，后续需要用到再说。 了解了这些内置的函数，就可以进行UDP TCP 编程了。\nUDP UDP 面向无连接的传输。\n创建指定类型的socket对象 udp_socket = socket(AF_INET, SOCK_DGRAM)\nrecvfrom() 接受数据 sendto() 发送数据 recvfrom() 方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用 sendto() 就可以把数据用UDP发给客户端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 实现udp 双向通信，使用多线程，要注意端口号的设置（在本地测试的时候） # 导包 from socket import * from threading import Thread udp_socket = socket(AF_INET, SOCK_DGRAM) udp_socket.bind((\u0026#39;127.0.0.1\u0026#39;, 8888)) # 接受信息的端口 def recv_data(): while True: redata = udp_socket.recvfrom(1024) print(f\u0026#34;收到信息：{redata[0].decode(\u0026#39;gbk\u0026#39;)}from{redata[1]}\u0026#34;) def send_data(): while True: addr1 = (\u0026#39;127.0.0.1\u0026#39;, 9999) data = input(\u0026#34;请输入你要传输的数据：\u0026#34;) udp_socket.sendto(data.encode(\u0026#34;gbk\u0026#34;), addr1) if __name__ == \u0026#39;__main__\u0026#39;: t1 = Thread(target=recv_data) t2 = Thread(target=send_data) t2.start() t1.start() t1.join() t2.join() udp_socket.close() 需要注意的一点是：结束网络连接后，记得关闭socket\nTCP 面向连接的可靠传输\n需要区分服务端和客户端以其实现的功能。\n服务端：\n创建socket对象 绑定IP和端口 监听 发送接收信息 关闭socket 客户端：\n创建socket对象 连接到服务端socket 发送接收信息 关闭socket 以下是多线程实现双向通信\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 服务端 # 多线程的服务端 from socket import * from threading import Thread def recv_data(): while True: # 接受数据，接受到“end”就停止 redata = tcs.recv(1024).decode(\u0026#39;gbk\u0026#39;) print(f\u0026#34;客户端说：{redata}\u0026#34;) if redata == \u0026#34;end\u0026#34;: break def send_data(): while True: msg = input(\u0026#34;\u0026gt;\u0026#34;) tcs.send(msg.encode(\u0026#34;gbk\u0026#34;)) if __name__ == \u0026#39;__main__\u0026#39;: # 1 创建socket套接字 tss = socket(AF_INET, SOCK_STREAM) # 2 绑定信息 tss.bind((\u0026#39;127.0.0.1\u0026#39;, 8888)) # 3 监听端口 tss.listen() print(\u0026#34;等待客户端连接......\u0026#34;) # 等待客户端连接，注意这里的放回的是个元组！ tcs, host = tss.accept() print(\u0026#34;客户端连接成功，等待传输数据\u0026#34;) # 4 发送和接收信息 t1 = Thread(target=recv_data) t2 = Thread(target=send_data) t1.start() t2.start() t1.join() t2.join() # 关闭 tss.close() tcs.count() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 多线程的客户端 from socket import * from threading import Thread def recv_data(): while True: # 接受数据，接受到“end”就停止 redata = tcs.recv(1024).decode(\u0026#39;gbk\u0026#39;) print(f\u0026#34;服务说：{redata}\u0026#34;) def send_data(): while True: msg = input(\u0026#34;\u0026gt;\u0026#34;) tcs.send(msg.encode(\u0026#34;gbk\u0026#34;)) if msg == \u0026#34;end\u0026#34;: break if __name__ == \u0026#39;__main__\u0026#39;: # 1 创建socket对象 tcs = socket(AF_INET, SOCK_STREAM) # 2 连接服务端 tcs.connect((\u0026#39;127.0.0.1\u0026#39;, 8888)) print(\u0026#34;连接成功，\u0026#34;) # 3 发送和接收信息 t1 = Thread(target=recv_data) t2 = Thread(target=send_data) t2.start() t1.start() t1.join() t2.join() # 4 关闭socket tcs.close() 到此，最简单的python网络编程就实现了，后续再学习传输相关文件\n","date":"2024-07-29T18:04:15+08:00","permalink":"http://localhost:1313/2024/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-1/","title":"python网络编程入门-1"},{"content":"网络编程 看了狂神说Java的网络编程课程后进行总结。 但是关于 网络编程的知识不止这些，各种I/O的深入了解，不同需要的具体实现等等都需要后续的深入学习。\n基本概念 基于TCP协议实现C/S架构的通信。（打电话） 基于UDP协议实现B/S架构的通信。（发短信） **计算机网络：**把地理位置不同的多台设备，通过通信协议实现资源共享。\n目的：数据交换、通信\n需要解决的问题：\n如何定位电脑主机？ —IP+port 如何传输数据 ？ — socket + I/O 流+ 通信协议 下面就基于这两个问题进行学习。\n网络通信的要素 通过分析：\n需要知道通信双方的IP地址以及提供通信的端口。 需要明确通信协议 （TCP、UDP） 我们选择的编程语言为Java，需要理解 **Java“万物皆对象”**的特征。\nIP Java 提供了 一个 InetAddress类，表示Internet协议(IP)地址。\n从官方文档中，InetAddress类并没有构造器，因此无法使用new 创建对象。（但是又静态方法。）\n以下为 构造InetAddress对象以及其常用方法。\n1 2 3 4 5 6 7 8 9 10 11 12 public class IpTest { public static void main(String[] args) throws UnknownHostException { // 使用静态方法 getByName() 构造对象，参数为 域名 或 IP地址 InetAddress inetaddress1 = InetAddress.getByName(\u0026#34;www.baidu.com\u0026#34;); System.out.println(inetaddress1); //打印主机地址 System.out.println(inetaddress1.getHostAddress()); //获取主机名 System.out.println(inetaddress1.getHostName()); } port 端口可以认为是设备与外界通讯交流的出口。也表示进程占用。\n大致分类：\n0-1023 公有端口。 如: HTTP 80 HTTPS 443 FTP 21 Telent 23 SSH 22 1024-19151 程序 19152-65535 动态私有 查看相关端口的命令：\n1 2 3 4 //查看端口占用 netsata -ano |find \u0026#34;xxx\u0026#34; //任务管理器 tasklist 通信协议： 为传输层协议，网络编程中使用实时连接TCP和无连接UDP。\n详细的就不在此赘述了。\n实现TCP实时连接 需要构造客户端、服务端。\n涉及到的类： InetAddress获取IP对象。\nsocket套接字：双方进行通信的一个抽象端口。\nI/O流：用于数据传输。\ngetBytes() 方法：将字符串转化为Byte序列，供以进行流传输。\n客户端 明确服务端的IP及端口 创建一个套接字地址 通过I/O传输数据(byte) 关闭资源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //客户端 public class tcpclinet { public static void main(String[] args) throws IOException { // id InetAddress inet = InetAddress.getByName(\u0026#34;127.0.0.1\u0026#34;); //port int port = 9999; //创建一个scoket地址 Socket socket = new Socket(inet, port); //发送信息，输出流 OutputStream os = socket.getOutputStream(); //这是是写出 btye 数据 os.write(\u0026#34;你好\u0026#34;.getBytes()); os.close(); } } 服务端 创建serverSocket套接字 等待客户端连接 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Tcpserver { public static void main(String[] args) throws IOException { // serversocket ServerSocket serverSocket = new ServerSocket(9999); // 等待连接 Socket accept = serverSocket.accept(); System.out.println(\u0026#34;连接成功\u0026#34;); // 读取客户端信息 InputStream is = accept.getInputStream(); // 管道流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer = new byte[4096]; int len ; while((len= is.read(buffer))!= -1 ) { baos.write(buffer,0,len); } System.out.println(baos.toString()); } } 实现TCP 发送文件 客户端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class ClientTest { public static void main(String[] args) throws IOException { Socket s = new Socket(\u0026#34;127.0.0.1\u0026#34;,8888); System.out.println(\u0026#34;客户端启动！准备接受文件！\u0026#34;); //数据输入流 DataInputStream dis = new DataInputStream(s.getInputStream()); //接收文件数量 int fileCount = dis.readInt(); System.out.println(\u0026#34;需要接收的文件个数：\u0026#34;+fileCount); //下载多少个文件 for (int i = 0; i \u0026lt; fileCount; i++) { //名字和长度 String fileName = dis.readUTF(); long fileSize = dis.readLong(); //利用文件输出流，创建文件 FileOutputStream fos = new FileOutputStream(\u0026#34;received_\u0026#34; + fileName); byte[] buffer = new byte[4096]; int bytesRead; long totalBytesRead = 0; while ((bytesRead = dis.read(buffer)) != -1) { fos.write(buffer,0,bytesRead); totalBytesRead +=bytesRead; if(totalBytesRead == fileSize) { break; } } System.out.println(\u0026#34;已接收文件：\u0026#34;+fileName); fos.close(); } dis.close(); s.close(); } } 服务端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 public class ServerTest { public static void main(String[] args) throws IOException { //开放8888端口 ServerSocket ss = new ServerSocket(8888); System.out.println(\u0026#34;服务端等待连接。。。。\u0026#34;); //客服端连接 Socket s = ss.accept(); OutputStream os = s.getOutputStream(); DataOutputStream dos = new DataOutputStream(s.getOutputStream()); System.out.println(\u0026#34;连接成功！传输文件\u0026#34;); //读取本地的多个文件 ,存放在一个数组里。 File File = new File(\u0026#34;./files\u0026#34;); File[] files = File.listFiles(); assert files != null; int len = files.length; //需要先发送文件的信息,文件数量 dos.writeInt(len); dos.flush(); //发送每个文件 for (java.io.File file : files) { //文件输入流。 FileInputStream fis = new FileInputStream(file); //获取文件的名字和长度 String fileName = file.getName(); long fileSize = file.length(); //把名字和长度传过去 dos.writeUTF(fileName); dos.writeLong(fileSize); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = fis.read(buffer)) != -1) { dos.write(buffer, 0, bytesRead); } fis.close(); System.out.println(\u0026#34;已发送文件：\u0026#34;+fileName); } //现在有思路是服务端就这样写，然后客户端创建对应的名字进行存储，应该考虑大小问题。 dos.close(); //多个文件传输 //FileInputStream file = new FileInputStream(files[0]); } } 实现UDP发送信息 UDP 协议则需要使用到 DatagramSocket 套接字 和 DatagramPacket 类。\n基本框架是：\n创建DatagramSocket套接字 创建packet 发送packet 发送端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Udpclient { public static void main(String[] args) throws IOException { // socket DatagramSocket socket = new DatagramSocket(); // creat packet String msg = \u0026#34;你好啊，服务器！\u0026#34;; InetAddress serverip = InetAddress.getByName(\u0026#34;127.0.0.1\u0026#34;); int port = 9999; //数据 ，发送给谁 5个参数 //将字符串编码为 byte 序列，并将结果存储到一个新的 byte 数组中 DatagramPacket packet = new DatagramPacket(msg.getBytes(), 0, msg.getBytes().length, serverip, port); // 发送包 socket.send(packet); socket.close(); } } 接受端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class udpserver { public static void main(String[] args) throws IOException { // 开放端口 DatagramSocket socket = new DatagramSocket(9999); // 接受数据 byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length); socket.receive(packet); System.out.println(packet.getAddress().getHostAddress()); System.out.println(new String(packet.getData(), 0, packet.getLength())); } } 至此实现了基础的发送信息。也可以优化成连续不断发送信息直到 ，发送方停止。\n只需要把对应的代码放入 while循环中，再通过添加终止条件，达到目的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ublic class UdpSender { public static void main(String[] args) throws IOException { DatagramSocket socket = new DatagramSocket(6666); BufferedReader render = new BufferedReader(new InputStreamReader(System.in)); while(true) { String data = render.readLine(); //处理字符串封装成包 byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(\u0026#34;127.0.0.1\u0026#34;,8888)); socket.send(packet); if(data.equals(\u0026#34;bye\u0026#34;)) { break; } } //发送的数据，从键盘获取 socket.close(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class UdpReceive { public static void main(String[] args) throws IOException { DatagramSocket socket = new DatagramSocket(8888); while(true) { byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length); socket.receive(packet); byte[] data = packet.getData(); String recevedata = new String(data,0, packet.getLength()); System.out.println(recevedata); if (recevedata.equals(\u0026#34;bye\u0026#34;)) { break; } } } } 在实现该功能时，遇到了一些问题:\nQ：在接受端，接受的数据长度很长。\n1 2 3 4 5 6 7 //错误代码 byte[] data = packet.getData(); String recevedata = new String(data,0, data.Lenth); //但是 data.Lenth的值为 1024 （发送端的数据长度），并不是发送过来的实际长度。 //实际长度应为 packet.getLenth() String recevedata = new String(data,0, packet.getLength()); 实现UDP聊天实现 要实现聊天的实现，就得学习Java 多线程，使得双方可以互相发送信息。\n需要 将 发送端以及接受端写入线程中。\n发送端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class TalkSent implements Runnable{ // 成员 DatagramSocket socket =null; BufferedReader render = null; private int fromprot; private String toip; private int toport; // 初始化进程 public TalkSent(int fromprot, String toip, int toport) { this.fromprot = fromprot; this.toip = toip; this.toport = toport; } // 子线程运行的内容 @Override public void run() { try { socket = new DatagramSocket(fromprot); render = new BufferedReader(new InputStreamReader(System.in)); while(true) { String data = render.readLine(); //处理字符串封装成包 byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas,0,datas.length,new InetSocketAddress(this.toip,this.toport)); socket.send(packet); if(data.equals(\u0026#34;bye\u0026#34;)) { break; } } } catch (Exception e) { throw new RuntimeException(e); } socket.close(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class TalkReceive implements Runnable{ DatagramSocket socket=null; private int fromPort; private String msgFrom; public TalkReceive(int fromPort,String msgFrom) throws SocketException { this.fromPort = fromPort; this.msgFrom = msgFrom; socket = new DatagramSocket(this.fromPort); } @Override public void run() { try { while(true) { byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length); socket.receive(packet); byte[] data = packet.getData(); // 为什么这里出错了,长度为为 1024 . String recevedata = new String(data,0, packet.getLength()); System.out.println(msgFrom+\u0026#34;:\u0026#34;+recevedata); if (recevedata.equals(\u0026#34;bye\u0026#34;)) { break; } } } catch (Exception e) { throw new RuntimeException(e); } } } 实现了这个对于 通信双方就容易了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class TalkStudent { public static void main(String[] args) throws SocketException { //开启两个线程 //发送到目标主机的9999端口 new Thread(new TalkSent(7777,\u0026#34;localhost\u0026#34;,9999)).start(); //接受来自 8888 端口的信息 。 new Thread(new TalkReceive(8888,\u0026#34;老师\u0026#34;)).start(); } } public class TalkTecher { public static void main(String[] args) throws SocketException { //发送到目标主机的8888端口 new Thread(new TalkSent(5555,\u0026#34;127.0.0.1\u0026#34;,8888)).start(); //接收9999端口的信息 new Thread(new TalkReceive(9999,\u0026#34;学生\u0026#34;)).start(); } } URL资源下载 需要用到 URL 类 以及 进行HttpURLconnection 网络连接。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class urlTest { public static void main(String[] args) throws IOException { URL url = new URL(\u0026#34;https://img3.doubanio.com/dae/accounts/resources/ded47ae/movie/assets/annual_2023.png\u0026#34;); // 进行 http连接 URLConnection connection = url.openConnection(); //HttpURLconnection urlconnection =(HttpURLconnection)url.openconnection(); // 输入流 InputStream is = connection.getInputStream(); System.out.println(connection); // 文件输出流，把文件保留在本地 FileOutputStream fos = new FileOutputStream(\u0026#34;a.png\u0026#34;); byte[] buffer = new byte[1024]; int len ; while((len=is.read(buffer))!= -1) { fos.write(buffer,0,len); } fos.close(); is.close(); } } ","date":"2024-04-23T23:08:18+08:00","permalink":"http://localhost:1313/2024/imgs/","title":"网络编程基础入门"},{"content":"hugo+stack 本主题由 CaiJimmy 制作并发布，这个仓库是由 Mantyke 修改的魔改版本\nGithub 仓库地址：Mantyke/stack-theme-mod\n参考文章：https://cuttontail.blog/blog/create-a-wesite-using-github-pages-and-hugo/（师傅写得很详细，我就不再赘述。）\n思路：GitHub pages + hugo 进行搭建博客。\n不过在途中遇到一些问题：hugo server 时总是报错，因此决定采取更加容易的搭建方式。\n可能原因是：\n主题模板与hugo 版本不适配。 模板中post文章的语法出错。 hugo 根据Hugo 文档：Install Hugo去安装hugo。\n1 2 #检查是否安装成功（extend版） hugo version stack 在项目目录下:(把Mantyke师傅的版本直接git到本地)\n1 git clone https://github.com/Mantyke/Hugo-stack-theme-mod.git 不再使用 hugo new site xxxx创建网点的方式进行搭建。\nGitHub pages 这个仓库必须使用特殊的命名格式 \u0026lt;username.github.io\u0026gt;， \u0026lt;username\u0026gt; 是自己的 GitHub 的用户名。\n发布 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #生成静态网页到public hugo #将 public 文件夹初始化为 Git 仓库，并设置默认主分支名为 main。 cd public git init -b main #需要设置 GitHub 的 ssh 链接 git remote add origin git@github.com:Rosewwwfr/Rosewwwfr.github.io.git git pull --rebase origin main git add . git commit -m \u0026#34;...(修改的信息)\u0026#34; git push origin main 后续管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #创建文章 hugo new xxx.md #本地调试 hugo server #生成html hugo #上传到GitHub pages git add . git commit -m \u0026#34;...(修改的信息)\u0026#34; git pull --rebase origin main #可选,如果远端仓库与本地一致，则不需要合并。 git push origin main 刚开始可以手动发布，后续学习 gitthub action 自动发布。\n相关配置 可以参考：官网的配置,写的十分清楚。\nhttps://mantyke.icu/posts/2022/stack-theme-mod/\n修改了一个实现分类双栏的效果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //-------------------------------------------------- // 文件位置：~/assets/scss/custom/_custom.scss /* 归档页面两栏 */ @media (min-width: 1024px) { .article-list--compact { display: grid; grid-template-columns: 1fr 1fr; background: none; box-shadow: none; gap: 1rem; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; border-radius: 16px; } } } 利用GitHub搭建简易图床 博客肯定少不了图片，手动上传就麻烦了一点，于是学一下搭建免费简易图床。参考\nGitHub 创建仓库 创建GitHub token 在 picgo 上设置。 image-20240410143656485\r在typroa 上设置 上传图片，方便写博客。\nimage-20240410143812940\r（先试试效果怎么样，不行再换）\n到此，博客已经可以开始使用了，后续无聊在进行改动。\n参考文章： pesudoyu师傅 cuttontail师傅\nhttps://stack.jimmycai.com/config/\n利用GitHub搭建免费图床\n","date":"2024-04-09T10:17:45+08:00","permalink":"http://localhost:1313/2024/hugo-stack%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/","title":"【hugo+stack】搭建过程"},{"content":"","date":"2024-04-09T09:15:49+08:00","permalink":"http://localhost:1313/2024/hello-world/","title":"Hello World！"}]